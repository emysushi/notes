/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HeaderEnhancerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");

// src/core.ts
function getHeaderLevel(text, startHeaderLevel) {
  const match = text.match(/^#+/);
  if (!match)
    return [0, 0];
  let level = match ? match[0].length : 0;
  return [level - startHeaderLevel + 1, level];
}
function getNextNumber(cntNums, headerLevel) {
  let nextNums = [...cntNums];
  if (nextNums.length >= headerLevel) {
    nextNums = nextNums.slice(0, headerLevel);
    nextNums[nextNums.length - 1]++;
  } else {
    while (nextNums.length < headerLevel) {
      nextNums.push(1);
    }
  }
  return nextNums;
}
function isNeedInsertNumber(text, splitor) {
  if (splitor == " ")
    return text.split(splitor).length === 2;
  else
    return !text.contains(splitor);
}
function isNeedUpdateNumber(nextNumsStr, text, splitor) {
  let cntNumsStr;
  if (splitor == " ") {
    cntNumsStr = text.split(splitor)[1];
  } else {
    cntNumsStr = text.split(splitor)[0].split(" ")[0];
  }
  return nextNumsStr !== cntNumsStr;
}
function removeHeaderNumber(text, splitor) {
  let sharp, header;
  if (splitor == " ") {
    sharp = text.split(splitor)[0];
    header = text.split(splitor)[2];
  } else {
    if (!text.contains(splitor))
      return text;
    sharp = text.split(splitor)[0].split(" ")[0];
    header = text.split(splitor)[1];
  }
  return sharp + " " + header;
}
function isHeader(text) {
  return /^#{1,6} .*/.test(text.trim());
}

// src/utils.ts
var import_obsidian = require("obsidian");
var YAML_REGEX = /^---\n(?:((?:.|\n)*?)\n)?---(?=\n|$)/;
var DEFAULT_YAML_SETTING = ["state on", "start-level h2", "max-level h1", "start-number 1", "separator ."];
function getYaml(editor) {
  var _a;
  const matchResult = editor.getValue().match(YAML_REGEX);
  return (_a = matchResult == null ? void 0 : matchResult[0]) != null ? _a : "";
}
function getAutoNumberingYaml(editor) {
  var _a;
  const yaml = getYaml(editor);
  const parsedYaml = (0, import_obsidian.parseYaml)(yaml.slice(4, -4));
  return (_a = parsedYaml == null ? void 0 : parsedYaml["header-auto-numbering"]) != null ? _a : "";
}
function setAutoNumberingYaml(editor, value = DEFAULT_YAML_SETTING) {
  const yaml = getYaml(editor);
  const parsedYaml = (0, import_obsidian.parseYaml)(yaml.slice(4, -4));
  if (parsedYaml) {
    parsedYaml["header-auto-numbering"] = value;
  }
  const newContent = `---
${(0, import_obsidian.stringifyYaml)(parsedYaml)}---`;
  const startPosition = { line: 0, ch: 0 };
  const endPosition = editor.offsetToPos(yaml.length);
  editor.replaceRange(newContent, startPosition, endPosition);
}

// src/setting.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  language: "en",
  showOnStatusBar: true,
  startHeaderLevel: 1,
  maxHeaderLevel: 6,
  isAutoNumbering: true,
  isUseYaml: true,
  autoNumberingStartNumber: "1",
  autoNumberingSeparator: ".",
  autoNumberingHeaderSeparator: "	",
  isSeparateTitleFont: true,
  titleFontFamily: "inherit",
  titleFontSize: "inherit"
};
var HeaderEnhancerSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Header Enhancer Settings" });
    containerEl.createEl("h2", { text: "General" });
    new import_obsidian2.Setting(containerEl).setName("Language").setDesc("Language for automatic numbering").addDropdown((dropdown) => {
      dropdown.addOption("en", "English");
      dropdown.addOption("zh", "Chinese");
      dropdown.setValue(this.plugin.settings.language);
      dropdown.onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Show on status bar").setDesc("Show automatic numbering status on status bar").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showOnStatusBar).onChange(async (value) => {
        this.plugin.settings.showOnStatusBar = value;
        await this.plugin.saveSettings();
        this.plugin.handleShowStateBarChange();
      });
    });
    containerEl.createEl("h2", { text: "Header Auto Numbering" });
    new import_obsidian2.Setting(containerEl).setName("Enable").setDesc("Enable auto numbering").setDisabled(true).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.isAutoNumbering).onChange(async (value) => {
        new import_obsidian2.Notice("You can only change this option in side bar");
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Use yaml").setDesc("use yaml control the format of header-number.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.isUseYaml).onChange(async (value) => {
        this.plugin.settings.isUseYaml = value;
        await this.plugin.saveSettings();
        this.plugin.handleShowStateBarChange();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Numbering header level").setDesc("The range of header level to be numbered").addDropdown((dropdown) => {
      dropdown.addOption("1", "H1");
      dropdown.addOption("2", "H2");
      dropdown.addOption("3", "H3");
      dropdown.addOption("4", "H4");
      dropdown.addOption("5", "H5");
      dropdown.addOption("6", "H6");
      dropdown.setValue(this.plugin.settings.startHeaderLevel.toString());
      dropdown.onChange(async (value) => {
        this.plugin.settings.startHeaderLevel = parseInt(value, 10);
        await this.plugin.saveSettings();
        formatExample.setName("Your auto numbering format is like : 	" + this.plugin.settings.autoNumberingStartNumber + this.plugin.settings.autoNumberingSeparator + "1" + this.plugin.settings.autoNumberingSeparator + "1	from H" + this.plugin.settings.startHeaderLevel + " to H" + this.plugin.settings.maxHeaderLevel);
      });
    }).addDropdown((dropdown) => {
      dropdown.addOption("1", "H1");
      dropdown.addOption("2", "H2");
      dropdown.addOption("3", "H3");
      dropdown.addOption("4", "H4");
      dropdown.addOption("5", "H5");
      dropdown.addOption("6", "H6");
      dropdown.setValue(this.plugin.settings.maxHeaderLevel.toString());
      dropdown.onChange(async (value) => {
        if (this.checkMaxLevel(parseInt(value, 10))) {
          this.plugin.settings.maxHeaderLevel = parseInt(value, 10);
          await this.plugin.saveSettings();
          formatExample.setName("Your auto numbering format is like : 	" + this.plugin.settings.autoNumberingStartNumber + this.plugin.settings.autoNumberingSeparator + "1" + this.plugin.settings.autoNumberingSeparator + "1	from H" + this.plugin.settings.startHeaderLevel + " to H" + this.plugin.settings.maxHeaderLevel);
        } else {
          new import_obsidian2.Notice("Max header level should be greater than or equal to start header level");
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Start number").setDesc("Start numbering at this number").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.autoNumberingStartNumber).onChange(async (value) => {
      if (this.checkStartNumber(value)) {
        this.plugin.settings.autoNumberingStartNumber = value;
        await this.plugin.saveSettings();
        formatExample.setName("Your auto numbering format is like : 	" + this.plugin.settings.autoNumberingStartNumber + this.plugin.settings.autoNumberingSeparator + "1" + this.plugin.settings.autoNumberingSeparator + "1	from H" + this.plugin.settings.startHeaderLevel + " to H" + this.plugin.settings.maxHeaderLevel);
      } else {
        new import_obsidian2.Notice("Start number should be a number");
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Separator").setDesc("Separator between numbers. Only support one of '. , / -'").addText((text) => text.setPlaceholder("Enter your separator").setValue(this.plugin.settings.autoNumberingSeparator).onChange(async (value) => {
      if (this.checkSeparator(value)) {
        this.plugin.settings.autoNumberingSeparator = value;
        await this.plugin.saveSettings();
        formatExample.setName("Your auto numbering format is like : 	" + this.plugin.settings.autoNumberingStartNumber + this.plugin.settings.autoNumberingSeparator + "1" + this.plugin.settings.autoNumberingSeparator + "1	from H" + this.plugin.settings.startHeaderLevel + " to H" + this.plugin.settings.maxHeaderLevel);
      } else {
        new import_obsidian2.Notice("Separator should be one of '. , / -'");
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Header separator").setDesc("Separator between header and number. default is tab").addDropdown((dropdown) => {
      dropdown.addOption("	", "Tab");
      dropdown.addOption(" ", "Space");
      dropdown.setValue(this.plugin.settings.autoNumberingHeaderSeparator);
      dropdown.onChange(async (value) => {
        if (this.checkHeaderSeparator(value)) {
          this.plugin.settings.autoNumberingHeaderSeparator = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian2.Notice("you can't change header separator when auto numbering is enabled");
        }
      });
    });
    const formatExample = new import_obsidian2.Setting(containerEl).setName(
      "Your auto numbering format is like : 	" + this.plugin.settings.autoNumberingStartNumber + this.plugin.settings.autoNumberingSeparator + "1" + this.plugin.settings.autoNumberingSeparator + "1	from H" + this.plugin.settings.startHeaderLevel + " to H" + this.plugin.settings.maxHeaderLevel
    );
    containerEl.createEl("h2", { text: "Isolate Title Font [W.I.P]" });
    new import_obsidian2.Setting(containerEl).setName("Enable").setDesc("Isolate title font from content").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.isSeparateTitleFont).onChange(async (value) => {
        new import_obsidian2.Notice("This feature is not available now, please wait for the next version");
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Font family").setDesc("Title font family, inherit from global font by default").addText((text) => text.setPlaceholder("global font").setValue(this.plugin.settings.titleFontFamily).onChange(async (value) => {
      this.plugin.settings.titleFontFamily = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Font size").setDesc("Title font size, inherit from global font size by default").addText((text) => text.setPlaceholder("global font size").setValue(this.plugin.settings.titleFontSize).onChange(async (value) => {
      this.plugin.settings.titleFontSize = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "More Info" });
    containerEl.createEl("p", { text: "Author: " }).createEl("a", {
      text: "Hobee Liu",
      href: "https://github.com/HoBeedzc"
    });
    containerEl.createEl("p", { text: "License: " }).createEl("a", {
      text: "MIT",
      href: "https://github.com/HoBeedzc/obsidian-header-enhancer-plugin/blob/master/LICENSE"
    });
    containerEl.createEl("p", { text: "Github Repo: " }).createEl("a", {
      text: "obsidian-header-enhancer",
      href: "https://github.com/HoBeedzc/obsidian-header-enhancer-plugin"
    });
    containerEl.createEl("p", { text: "Any question? Send feedback on " }).createEl("a", {
      text: "Github Issues",
      href: "https://github.com/HoBeedzc/obsidian-header-enhancer-plugin/issues"
    });
  }
  checkMaxLevel(maxLevel) {
    return this.plugin.settings.startHeaderLevel <= maxLevel;
  }
  checkStartNumber(startNumber) {
    const reg = /^[0-9]*$/;
    return reg.test(startNumber);
  }
  checkSeparator(separator) {
    if (separator.length != 1) {
      return false;
    }
    const separators = [".", ",", "-", "/"];
    return separators.includes(separator);
  }
  checkHeaderSeparator(separator) {
    if (this.plugin.settings.isAutoNumbering) {
      return false;
    }
    return true;
  }
};

// src/config.ts
function getAutoNumberingConfig(setting, editor) {
  const config = {
    state: setting.isAutoNumbering,
    startLevel: setting.startHeaderLevel,
    maxLevel: setting.maxHeaderLevel,
    startNumber: parseInt(setting.autoNumberingStartNumber),
    separator: setting.autoNumberingSeparator
  };
  if (setting.isUseYaml) {
    const yaml = getAutoNumberingYaml(editor);
    if (yaml === "")
      return config;
    for (const item of yaml) {
      const [key, value] = item.split(" ");
      switch (key) {
        case "state":
          config.state = value == "on" ? true : false;
          break;
        case "start-level":
          config.startLevel = parseInt(value[1]);
          break;
        case "max-level":
          config.maxLevel = parseInt(value[1]);
          break;
        case "start-number":
          config.startNumber = parseInt(value);
          break;
        case "separator":
          config.separator = value;
          break;
      }
    }
  }
  return config;
}

// src/main.ts
var HeaderEnhancerPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon("document", "Header Enhancer", (evt) => {
      const app2 = this.app;
      const activeView = app2.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (!activeView) {
        new import_obsidian3.Notice("No active MarkdownView, cannot toggle auto numbering.");
        return;
      }
      if (this.settings.isAutoNumbering) {
        this.settings.isAutoNumbering = false;
        new import_obsidian3.Notice("Auto numbering is off");
        this.handleRemoveHeaderNumber(activeView);
      } else {
        this.settings.isAutoNumbering = true;
        new import_obsidian3.Notice("Auto numbering is on");
        this.handleAddHeaderNumber(activeView);
      }
      this.handleShowStateBarChange();
    });
    this.statusBarItemEl = this.addStatusBarItem();
    this.handleShowStateBarChange();
    this.registerEditorExtension(import_state.Prec.highest(import_view.keymap.of([
      {
        key: "Enter",
        run: (view) => {
          const success = this.handlePressEnter(view);
          return success;
        }
      }
    ])));
    this.registerEditorExtension(import_state.Prec.highest(import_view.keymap.of([
      {
        key: "Backspace",
        run: (view) => {
          const success = this.handlePressBackspace(view);
          return success;
        }
      }
    ])));
    this.addCommand({
      id: "toggle-auto-numbering",
      name: "toggle auto numbering",
      callback: () => {
        const app2 = this.app;
        const activeView = app2.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView) {
          new import_obsidian3.Notice("No active MarkdownView, cannot toggle auto numbering.");
          return;
        }
        if (this.settings.isAutoNumbering) {
          this.settings.isAutoNumbering = false;
          new import_obsidian3.Notice("Auto numbering is off");
          this.handleRemoveHeaderNumber(activeView);
        } else {
          this.settings.isAutoNumbering = true;
          new import_obsidian3.Notice("Auto numbering is on");
          this.handleAddHeaderNumber(activeView);
        }
        this.handleShowStateBarChange();
      }
    });
    this.addCommand({
      id: "add-auto-numbering-yaml",
      name: "add auto numbering yaml",
      callback: () => {
        app = this.app;
        const activeView = app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView) {
          new import_obsidian3.Notice("No active MarkdownView, cannot add auto numbering yaml.");
          return;
        } else {
          const editor = activeView.editor;
          const yaml = getAutoNumberingYaml(editor);
          if (yaml === "") {
            setAutoNumberingYaml(editor);
          } else {
            new import_obsidian3.Notice("auto numbering yaml already exists");
          }
        }
      }
    });
    this.addCommand({
      id: "reset-auto-numbering-yaml",
      name: "reset auto numbering yaml",
      callback: () => {
        app = this.app;
        const activeView = app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView) {
          new import_obsidian3.Notice("No active MarkdownView, cannot reset auto numbering yaml.");
          return;
        } else {
          const editor = activeView.editor;
          const yaml = getAutoNumberingYaml(editor);
          if (yaml === "") {
            new import_obsidian3.Notice("auto numbering yaml not exists");
          } else {
            const value = ["state on", "first-level h2", "max 1", "start-at 1", "separator ."];
            setAutoNumberingYaml(editor, value);
          }
        }
      }
    });
    this.addCommand({
      id: "remove-auto-numbering-yaml",
      name: "remove auto numbering yaml",
      callback: () => {
        app = this.app;
        const activeView = app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (!activeView) {
          new import_obsidian3.Notice("No active MarkdownView, cannot remove auto numbering yaml.");
          return;
        } else {
          const editor = activeView.editor;
          const yaml = getAutoNumberingYaml(editor);
          if (yaml === "") {
            new import_obsidian3.Notice("auto numbering yaml not exists");
          } else {
            setAutoNumberingYaml(editor, []);
          }
        }
      }
    });
    this.addSettingTab(new HeaderEnhancerSettingTab(this.app, this));
    this.registerInterval(window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  handleShowStateBarChange() {
    if (this.settings.showOnStatusBar) {
      const autoNumberingStatus = this.settings.isAutoNumbering ? "On" : "Off";
      this.statusBarItemEl.setText("Auto Numbering: " + autoNumberingStatus);
    } else {
      this.statusBarItemEl.setText("");
    }
  }
  handleAddHeaderNumber(view) {
    const editor = view.editor;
    const lineCount = editor.lineCount();
    let docCharCount = 0;
    const config = getAutoNumberingConfig(this.settings, editor);
    if (!this.settings.isAutoNumbering) {
      return false;
    }
    if (config.state) {
      let insertNumber = [Number(config.startNumber) - 1];
      for (let i = 0; i <= lineCount; i++) {
        const line = editor.getLine(i);
        docCharCount += line.length;
        if (isHeader(line)) {
          const [headerLevel, realHeaderLevel] = getHeaderLevel(line, config.startLevel);
          if (headerLevel <= 0) {
            continue;
          }
          insertNumber = getNextNumber(insertNumber, headerLevel);
          const insertNumberStr = insertNumber.join(config.separator);
          if (isNeedInsertNumber(line, this.settings.autoNumberingHeaderSeparator)) {
            editor.setLine(i, "#".repeat(realHeaderLevel) + " " + insertNumberStr + this.settings.autoNumberingHeaderSeparator + line.substring(realHeaderLevel + 1));
          } else if (isNeedUpdateNumber(insertNumberStr, line, this.settings.autoNumberingHeaderSeparator)) {
            const originNumberLength = line.split(this.settings.autoNumberingHeaderSeparator)[0].split(" ")[1].length;
            editor.setLine(i, "#".repeat(realHeaderLevel) + " " + insertNumberStr + line.substring(realHeaderLevel + originNumberLength + 1));
          }
        }
      }
    }
    return true;
  }
  handleRemoveHeaderNumber(view) {
    const editor = view.editor;
    const lineCount = editor.lineCount();
    const config = getAutoNumberingConfig(this.settings, editor);
    if (!this.settings.isAutoNumbering) {
      for (let i = 0; i <= lineCount; i++) {
        const line = editor.getLine(i);
        if (isHeader(line)) {
          const [headerLevel, _] = getHeaderLevel(line, config.startLevel);
          if (headerLevel <= 0) {
            continue;
          }
          editor.setLine(i, removeHeaderNumber(line, this.settings.autoNumberingHeaderSeparator));
        }
      }
    }
    return true;
  }
  handlePressEnter(view) {
    let state = view.state;
    let doc = state.doc;
    const pos = state.selection.main.to;
    const lineCount = doc.lines;
    const changes = [];
    let docCharCount = 0;
    let insertCharCount = 0;
    let insertCharCountBeforePos = 0;
    const app2 = this.app;
    const activeView = app2.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView) {
      new import_obsidian3.Notice("No active MarkdownView, cannot toggle auto numbering.");
      return false;
    }
    if (!this.settings.isAutoNumbering) {
      return false;
    }
    const editor = activeView.editor;
    const config = getAutoNumberingConfig(this.settings, editor);
    if (!isHeader(doc.lineAt(pos).text)) {
      return false;
    }
    changes.push({
      from: pos,
      to: pos,
      insert: "\n"
    });
    if (config.state) {
      let insertNumber = [Number(config.startNumber) - 1];
      for (let i = 1; i <= lineCount; i++) {
        const line = doc.line(i);
        const fromPos = line.from;
        docCharCount += line.length;
        if (isHeader(line.text)) {
          const [headerLevel, realHeaderLevel] = getHeaderLevel(line.text, config.startLevel);
          if (headerLevel <= 0) {
            continue;
          }
          insertNumber = getNextNumber(insertNumber, headerLevel);
          const insertNumberStr = insertNumber.join(config.separator);
          if (isNeedInsertNumber(line.text, this.settings.autoNumberingHeaderSeparator)) {
            if (docCharCount <= pos) {
              insertCharCountBeforePos += insertNumberStr.length + 1;
            }
            insertCharCount += insertNumberStr.length + 1;
            docCharCount += insertNumberStr.length + 1;
            changes.push({
              from: fromPos + realHeaderLevel + 1,
              to: fromPos + realHeaderLevel + 1,
              insert: insertNumberStr + this.settings.autoNumberingHeaderSeparator
            });
          } else if (isNeedUpdateNumber(insertNumberStr, line.text, this.settings.autoNumberingHeaderSeparator)) {
            const fromPos2 = line.from + realHeaderLevel + 1;
            const toPos = fromPos2 + line.text.split(this.settings.autoNumberingHeaderSeparator)[0].split(" ")[1].length;
            if (docCharCount <= pos) {
              insertCharCountBeforePos += insertNumberStr.length - toPos + fromPos2;
            }
            insertCharCount += insertNumberStr.length - toPos + fromPos2;
            docCharCount += insertNumberStr.length - toPos + fromPos2;
            changes.push({
              from: fromPos2,
              to: toPos,
              insert: insertNumberStr
            });
          }
        }
      }
    }
    view.dispatch({
      changes,
      selection: { anchor: pos + 1 + insertCharCountBeforePos },
      userEvent: "HeaderEnhancer.changeAutoNumbering"
    });
    return true;
  }
  handlePressBackspace(view) {
    let state = view.state;
    let doc = state.doc;
    const pos = state.selection.main.to;
    const lineCount = doc.lines;
    const changes = [];
    let docCharCount = 0;
    let insertCharCount = 0;
    let insertCharCountBeforePos = 0;
    if (!isHeader(doc.lineAt(pos).text)) {
      return false;
    }
    changes.push({
      from: pos - 1,
      to: pos,
      insert: ""
    });
    if (this.settings.isAutoNumbering) {
    }
    view.dispatch({
      changes,
      selection: { anchor: pos - 1 },
      userEvent: "HeaderEnhancer.changeAutoNumbering"
    });
    return true;
  }
};
