/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/fuzzysort/fuzzysort.js
var require_fuzzysort = __commonJS({
  "node_modules/fuzzysort/fuzzysort.js"(exports, module2) {
    ((root, UMD) => {
      if (typeof define === "function" && define.amd)
        define([], UMD);
      else if (typeof module2 === "object" && module2.exports)
        module2.exports = UMD();
      else
        root["fuzzysort"] = UMD();
    })(exports, (_) => {
      "use strict";
      var single = (search, target) => {
        if (search == "farzher")
          return { target: "farzher was here (^-^*)/", score: 0, _indexes: [0] };
        if (!search || !target)
          return NULL;
        var preparedSearch = getPreparedSearch(search);
        if (!isObj(target))
          target = getPrepared(target);
        var searchBitflags = preparedSearch.bitflags;
        if ((searchBitflags & target._bitflags) !== searchBitflags)
          return NULL;
        return algorithm(preparedSearch, target);
      };
      var go = (search, targets, options) => {
        if (search == "farzher")
          return [{ target: "farzher was here (^-^*)/", score: 0, _indexes: [0], obj: targets ? targets[0] : NULL }];
        if (!search)
          return options && options.all ? all(search, targets, options) : noResults;
        var preparedSearch = getPreparedSearch(search);
        var searchBitflags = preparedSearch.bitflags;
        var containsSpace = preparedSearch.containsSpace;
        var threshold = options && options.threshold || INT_MIN;
        var limit = options && options["limit"] || INT_MAX;
        var resultsLen = 0;
        var limitedCount = 0;
        var targetsLen = targets.length;
        if (options && options.key) {
          var key = options.key;
          for (var i = 0; i < targetsLen; ++i) {
            var obj = targets[i];
            var target = getValue(obj, key);
            if (!target)
              continue;
            if (!isObj(target))
              target = getPrepared(target);
            if ((searchBitflags & target._bitflags) !== searchBitflags)
              continue;
            var result = algorithm(preparedSearch, target);
            if (result === NULL)
              continue;
            if (result.score < threshold)
              continue;
            result = { target: result.target, _targetLower: "", _targetLowerCodes: NULL, _nextBeginningIndexes: NULL, _bitflags: 0, score: result.score, _indexes: result._indexes, obj };
            if (resultsLen < limit) {
              q.add(result);
              ++resultsLen;
            } else {
              ++limitedCount;
              if (result.score > q.peek().score)
                q.replaceTop(result);
            }
          }
        } else if (options && options.keys) {
          var scoreFn = options["scoreFn"] || defaultScoreFn;
          var keys = options.keys;
          var keysLen = keys.length;
          for (var i = 0; i < targetsLen; ++i) {
            var obj = targets[i];
            var objResults = new Array(keysLen);
            for (var keyI = 0; keyI < keysLen; ++keyI) {
              var key = keys[keyI];
              var target = getValue(obj, key);
              if (!target) {
                objResults[keyI] = NULL;
                continue;
              }
              if (!isObj(target))
                target = getPrepared(target);
              if ((searchBitflags & target._bitflags) !== searchBitflags)
                objResults[keyI] = NULL;
              else
                objResults[keyI] = algorithm(preparedSearch, target);
            }
            objResults.obj = obj;
            var score = scoreFn(objResults);
            if (score === NULL)
              continue;
            if (score < threshold)
              continue;
            objResults.score = score;
            if (resultsLen < limit) {
              q.add(objResults);
              ++resultsLen;
            } else {
              ++limitedCount;
              if (score > q.peek().score)
                q.replaceTop(objResults);
            }
          }
        } else {
          for (var i = 0; i < targetsLen; ++i) {
            var target = targets[i];
            if (!target)
              continue;
            if (!isObj(target))
              target = getPrepared(target);
            if ((searchBitflags & target._bitflags) !== searchBitflags)
              continue;
            var result = algorithm(preparedSearch, target);
            if (result === NULL)
              continue;
            if (result.score < threshold)
              continue;
            if (resultsLen < limit) {
              q.add(result);
              ++resultsLen;
            } else {
              ++limitedCount;
              if (result.score > q.peek().score)
                q.replaceTop(result);
            }
          }
        }
        if (resultsLen === 0)
          return noResults;
        var results = new Array(resultsLen);
        for (var i = resultsLen - 1; i >= 0; --i)
          results[i] = q.poll();
        results.total = resultsLen + limitedCount;
        return results;
      };
      var highlight = (result, hOpen, hClose) => {
        if (typeof hOpen === "function")
          return highlightCallback(result, hOpen);
        if (result === NULL)
          return NULL;
        if (hOpen === void 0)
          hOpen = "<b>";
        if (hClose === void 0)
          hClose = "</b>";
        var highlighted = "";
        var matchesIndex = 0;
        var opened = false;
        var target = result.target;
        var targetLen = target.length;
        var indexes2 = result._indexes;
        indexes2 = indexes2.slice(0, indexes2.len).sort((a, b) => a - b);
        for (var i = 0; i < targetLen; ++i) {
          var char = target[i];
          if (indexes2[matchesIndex] === i) {
            ++matchesIndex;
            if (!opened) {
              opened = true;
              highlighted += hOpen;
            }
            if (matchesIndex === indexes2.length) {
              highlighted += char + hClose + target.substr(i + 1);
              break;
            }
          } else {
            if (opened) {
              opened = false;
              highlighted += hClose;
            }
          }
          highlighted += char;
        }
        return highlighted;
      };
      var highlightCallback = (result, cb) => {
        if (result === NULL)
          return NULL;
        var target = result.target;
        var targetLen = target.length;
        var indexes2 = result._indexes;
        indexes2 = indexes2.slice(0, indexes2.len).sort((a, b) => a - b);
        var highlighted = "";
        var matchI = 0;
        var indexesI = 0;
        var opened = false;
        var result = [];
        for (var i = 0; i < targetLen; ++i) {
          var char = target[i];
          if (indexes2[indexesI] === i) {
            ++indexesI;
            if (!opened) {
              opened = true;
              result.push(highlighted);
              highlighted = "";
            }
            if (indexesI === indexes2.length) {
              highlighted += char;
              result.push(cb(highlighted, matchI++));
              highlighted = "";
              result.push(target.substr(i + 1));
              break;
            }
          } else {
            if (opened) {
              opened = false;
              result.push(cb(highlighted, matchI++));
              highlighted = "";
            }
          }
          highlighted += char;
        }
        return result;
      };
      var indexes = (result) => result._indexes.slice(0, result._indexes.len).sort((a, b) => a - b);
      var prepare = (target) => {
        if (typeof target !== "string")
          target = "";
        var info = prepareLowerInfo(target);
        return { "target": target, _targetLower: info._lower, _targetLowerCodes: info.lowerCodes, _nextBeginningIndexes: NULL, _bitflags: info.bitflags, "score": NULL, _indexes: [0], "obj": NULL };
      };
      var prepareSearch = (search) => {
        if (typeof search !== "string")
          search = "";
        search = search.trim();
        var info = prepareLowerInfo(search);
        var spaceSearches = [];
        if (info.containsSpace) {
          var searches = search.split(/\s+/);
          searches = [...new Set(searches)];
          for (var i = 0; i < searches.length; i++) {
            if (searches[i] === "")
              continue;
            var _info = prepareLowerInfo(searches[i]);
            spaceSearches.push({ lowerCodes: _info.lowerCodes, _lower: searches[i].toLowerCase(), containsSpace: false });
          }
        }
        return { lowerCodes: info.lowerCodes, bitflags: info.bitflags, containsSpace: info.containsSpace, _lower: info._lower, spaceSearches };
      };
      var getPrepared = (target) => {
        if (target.length > 999)
          return prepare(target);
        var targetPrepared = preparedCache.get(target);
        if (targetPrepared !== void 0)
          return targetPrepared;
        targetPrepared = prepare(target);
        preparedCache.set(target, targetPrepared);
        return targetPrepared;
      };
      var getPreparedSearch = (search) => {
        if (search.length > 999)
          return prepareSearch(search);
        var searchPrepared = preparedSearchCache.get(search);
        if (searchPrepared !== void 0)
          return searchPrepared;
        searchPrepared = prepareSearch(search);
        preparedSearchCache.set(search, searchPrepared);
        return searchPrepared;
      };
      var all = (search, targets, options) => {
        var results = [];
        results.total = targets.length;
        var limit = options && options.limit || INT_MAX;
        if (options && options.key) {
          for (var i = 0; i < targets.length; i++) {
            var obj = targets[i];
            var target = getValue(obj, options.key);
            if (!target)
              continue;
            if (!isObj(target))
              target = getPrepared(target);
            target.score = INT_MIN;
            target._indexes.len = 0;
            var result = target;
            result = { target: result.target, _targetLower: "", _targetLowerCodes: NULL, _nextBeginningIndexes: NULL, _bitflags: 0, score: target.score, _indexes: NULL, obj };
            results.push(result);
            if (results.length >= limit)
              return results;
          }
        } else if (options && options.keys) {
          for (var i = 0; i < targets.length; i++) {
            var obj = targets[i];
            var objResults = new Array(options.keys.length);
            for (var keyI = options.keys.length - 1; keyI >= 0; --keyI) {
              var target = getValue(obj, options.keys[keyI]);
              if (!target) {
                objResults[keyI] = NULL;
                continue;
              }
              if (!isObj(target))
                target = getPrepared(target);
              target.score = INT_MIN;
              target._indexes.len = 0;
              objResults[keyI] = target;
            }
            objResults.obj = obj;
            objResults.score = INT_MIN;
            results.push(objResults);
            if (results.length >= limit)
              return results;
          }
        } else {
          for (var i = 0; i < targets.length; i++) {
            var target = targets[i];
            if (!target)
              continue;
            if (!isObj(target))
              target = getPrepared(target);
            target.score = INT_MIN;
            target._indexes.len = 0;
            results.push(target);
            if (results.length >= limit)
              return results;
          }
        }
        return results;
      };
      var algorithm = (preparedSearch, prepared, allowSpaces = false) => {
        if (allowSpaces === false && preparedSearch.containsSpace)
          return algorithmSpaces(preparedSearch, prepared);
        var searchLower = preparedSearch._lower;
        var searchLowerCodes = preparedSearch.lowerCodes;
        var searchLowerCode = searchLowerCodes[0];
        var targetLowerCodes = prepared._targetLowerCodes;
        var searchLen = searchLowerCodes.length;
        var targetLen = targetLowerCodes.length;
        var searchI = 0;
        var targetI = 0;
        var matchesSimpleLen = 0;
        for (; ; ) {
          var isMatch = searchLowerCode === targetLowerCodes[targetI];
          if (isMatch) {
            matchesSimple[matchesSimpleLen++] = targetI;
            ++searchI;
            if (searchI === searchLen)
              break;
            searchLowerCode = searchLowerCodes[searchI];
          }
          ++targetI;
          if (targetI >= targetLen)
            return NULL;
        }
        var searchI = 0;
        var successStrict = false;
        var matchesStrictLen = 0;
        var nextBeginningIndexes = prepared._nextBeginningIndexes;
        if (nextBeginningIndexes === NULL)
          nextBeginningIndexes = prepared._nextBeginningIndexes = prepareNextBeginningIndexes(prepared.target);
        var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];
        var backtrackCount = 0;
        if (targetI !== targetLen)
          for (; ; ) {
            if (targetI >= targetLen) {
              if (searchI <= 0)
                break;
              ++backtrackCount;
              if (backtrackCount > 200)
                break;
              --searchI;
              var lastMatch = matchesStrict[--matchesStrictLen];
              targetI = nextBeginningIndexes[lastMatch];
            } else {
              var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];
              if (isMatch) {
                matchesStrict[matchesStrictLen++] = targetI;
                ++searchI;
                if (searchI === searchLen) {
                  successStrict = true;
                  break;
                }
                ++targetI;
              } else {
                targetI = nextBeginningIndexes[targetI];
              }
            }
          }
        var substringIndex = prepared._targetLower.indexOf(searchLower, matchesSimple[0]);
        var isSubstring = ~substringIndex;
        if (isSubstring && !successStrict) {
          for (var i = 0; i < matchesSimpleLen; ++i)
            matchesSimple[i] = substringIndex + i;
        }
        var isSubstringBeginning = false;
        if (isSubstring) {
          isSubstringBeginning = prepared._nextBeginningIndexes[substringIndex - 1] === substringIndex;
        }
        {
          if (successStrict) {
            var matchesBest = matchesStrict;
            var matchesBestLen = matchesStrictLen;
          } else {
            var matchesBest = matchesSimple;
            var matchesBestLen = matchesSimpleLen;
          }
          var score = 0;
          var extraMatchGroupCount = 0;
          for (var i = 1; i < searchLen; ++i) {
            if (matchesBest[i] - matchesBest[i - 1] !== 1) {
              score -= matchesBest[i];
              ++extraMatchGroupCount;
            }
          }
          var unmatchedDistance = matchesBest[searchLen - 1] - matchesBest[0] - (searchLen - 1);
          score -= (12 + unmatchedDistance) * extraMatchGroupCount;
          if (matchesBest[0] !== 0)
            score -= matchesBest[0] * matchesBest[0] * 0.2;
          if (!successStrict) {
            score *= 1e3;
          } else {
            var uniqueBeginningIndexes = 1;
            for (var i = nextBeginningIndexes[0]; i < targetLen; i = nextBeginningIndexes[i])
              ++uniqueBeginningIndexes;
            if (uniqueBeginningIndexes > 24)
              score *= (uniqueBeginningIndexes - 24) * 10;
          }
          if (isSubstring)
            score /= 1 + searchLen * searchLen * 1;
          if (isSubstringBeginning)
            score /= 1 + searchLen * searchLen * 1;
          score -= targetLen - searchLen;
          prepared.score = score;
          for (var i = 0; i < matchesBestLen; ++i)
            prepared._indexes[i] = matchesBest[i];
          prepared._indexes.len = matchesBestLen;
          return prepared;
        }
      };
      var algorithmSpaces = (preparedSearch, target) => {
        var seen_indexes = /* @__PURE__ */ new Set();
        var score = 0;
        var result = NULL;
        var first_seen_index_last_search = 0;
        var searches = preparedSearch.spaceSearches;
        for (var i = 0; i < searches.length; ++i) {
          var search = searches[i];
          result = algorithm(search, target);
          if (result === NULL)
            return NULL;
          score += result.score;
          if (result._indexes[0] < first_seen_index_last_search) {
            score -= first_seen_index_last_search - result._indexes[0];
          }
          first_seen_index_last_search = result._indexes[0];
          for (var j = 0; j < result._indexes.len; ++j)
            seen_indexes.add(result._indexes[j]);
        }
        var allowSpacesResult = algorithm(
          preparedSearch,
          target,
          /*allowSpaces=*/
          true
        );
        if (allowSpacesResult !== NULL && allowSpacesResult.score > score) {
          return allowSpacesResult;
        }
        result.score = score;
        var i = 0;
        for (let index of seen_indexes)
          result._indexes[i++] = index;
        result._indexes.len = i;
        return result;
      };
      var prepareLowerInfo = (str) => {
        var strLen = str.length;
        var lower = str.toLowerCase();
        var lowerCodes = [];
        var bitflags = 0;
        var containsSpace = false;
        for (var i = 0; i < strLen; ++i) {
          var lowerCode = lowerCodes[i] = lower.charCodeAt(i);
          if (lowerCode === 32) {
            containsSpace = true;
            continue;
          }
          var bit = lowerCode >= 97 && lowerCode <= 122 ? lowerCode - 97 : lowerCode >= 48 && lowerCode <= 57 ? 26 : lowerCode <= 127 ? 30 : 31;
          bitflags |= 1 << bit;
        }
        return { lowerCodes, bitflags, containsSpace, _lower: lower };
      };
      var prepareBeginningIndexes = (target) => {
        var targetLen = target.length;
        var beginningIndexes = [];
        var beginningIndexesLen = 0;
        var wasUpper = false;
        var wasAlphanum = false;
        for (var i = 0; i < targetLen; ++i) {
          var targetCode = target.charCodeAt(i);
          var isUpper = targetCode >= 65 && targetCode <= 90;
          var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;
          var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;
          wasUpper = isUpper;
          wasAlphanum = isAlphanum;
          if (isBeginning)
            beginningIndexes[beginningIndexesLen++] = i;
        }
        return beginningIndexes;
      };
      var prepareNextBeginningIndexes = (target) => {
        var targetLen = target.length;
        var beginningIndexes = prepareBeginningIndexes(target);
        var nextBeginningIndexes = [];
        var lastIsBeginning = beginningIndexes[0];
        var lastIsBeginningI = 0;
        for (var i = 0; i < targetLen; ++i) {
          if (lastIsBeginning > i) {
            nextBeginningIndexes[i] = lastIsBeginning;
          } else {
            lastIsBeginning = beginningIndexes[++lastIsBeginningI];
            nextBeginningIndexes[i] = lastIsBeginning === void 0 ? targetLen : lastIsBeginning;
          }
        }
        return nextBeginningIndexes;
      };
      var cleanup = () => {
        preparedCache.clear();
        preparedSearchCache.clear();
        matchesSimple = [];
        matchesStrict = [];
      };
      var preparedCache = /* @__PURE__ */ new Map();
      var preparedSearchCache = /* @__PURE__ */ new Map();
      var matchesSimple = [];
      var matchesStrict = [];
      var defaultScoreFn = (a) => {
        var max2 = INT_MIN;
        var len = a.length;
        for (var i = 0; i < len; ++i) {
          var result = a[i];
          if (result === NULL)
            continue;
          var score = result.score;
          if (score > max2)
            max2 = score;
        }
        if (max2 === INT_MIN)
          return NULL;
        return max2;
      };
      var getValue = (obj, prop) => {
        var tmp = obj[prop];
        if (tmp !== void 0)
          return tmp;
        var segs = prop;
        if (!Array.isArray(prop))
          segs = prop.split(".");
        var len = segs.length;
        var i = -1;
        while (obj && ++i < len)
          obj = obj[segs[i]];
        return obj;
      };
      var isObj = (x) => {
        return typeof x === "object";
      };
      var INT_MAX = Infinity;
      var INT_MIN = -INT_MAX;
      var noResults = [];
      noResults.total = 0;
      var NULL = null;
      var fastpriorityqueue = (r) => {
        var e = [], o = 0, a = {}, v = (r2) => {
          for (var a2 = 0, v2 = e[a2], c = 1; c < o; ) {
            var s = c + 1;
            a2 = c, s < o && e[s].score < e[c].score && (a2 = s), e[a2 - 1 >> 1] = e[a2], c = 1 + (a2 << 1);
          }
          for (var f = a2 - 1 >> 1; a2 > 0 && v2.score < e[f].score; f = (a2 = f) - 1 >> 1)
            e[a2] = e[f];
          e[a2] = v2;
        };
        return a.add = (r2) => {
          var a2 = o;
          e[o++] = r2;
          for (var v2 = a2 - 1 >> 1; a2 > 0 && r2.score < e[v2].score; v2 = (a2 = v2) - 1 >> 1)
            e[a2] = e[v2];
          e[a2] = r2;
        }, a.poll = (r2) => {
          if (0 !== o) {
            var a2 = e[0];
            return e[0] = e[--o], v(), a2;
          }
        }, a.peek = (r2) => {
          if (0 !== o)
            return e[0];
        }, a.replaceTop = (r2) => {
          e[0] = r2, v();
        }, a;
      };
      var q = fastpriorityqueue();
      return { "single": single, "go": go, "highlight": highlight, "prepare": prepare, "indexes": indexes, "cleanup": cleanup };
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AtSymbolLinking
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/settings/settings.ts
var import_obsidian3 = require("obsidian");

// src/settings/folder-suggest.ts
var import_fuzzysort = __toESM(require_fuzzysort());
var import_obsidian2 = require("obsidian");

// src/utils/highlight-search.ts
function highlightSearch(element, result) {
  if (result === null)
    return;
  let matchesIndex = 0;
  let opened = false;
  const target = result.target;
  const targetLen = target.length;
  let indexes = result._indexes;
  indexes = indexes.slice(0, indexes.len).sort((a, b) => a - b);
  let strongElement = void 0;
  for (let i = 0; i < targetLen; ++i) {
    const char = target[i];
    if (indexes[matchesIndex] === i) {
      ++matchesIndex;
      if (!opened) {
        opened = true;
        strongElement = document.createElement("strong");
      }
      if (matchesIndex === indexes.length) {
        strongElement.appendChild(
          document.createTextNode(char)
        );
        element.appendChild(strongElement);
        element.appendChild(
          document.createTextNode(target.substr(i + 1))
        );
        break;
      }
    } else {
      if (opened) {
        opened = false;
        element.appendChild(strongElement);
        strongElement = void 0;
      }
    }
    if (strongElement) {
      strongElement.appendChild(document.createTextNode(char));
    } else {
      element.appendChild(document.createTextNode(char));
    }
  }
}

// src/utils/suggest.ts
var import_obsidian = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/utils/suggest.ts
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app2, inputEl, settings) {
    this.app = app2;
    this.inputEl = inputEl;
    this.scope = new import_obsidian.Scope();
    this.settings = settings;
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    var _a;
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    (_a = this.popper) == null ? void 0 : _a.destroy();
    this.suggestEl.detach();
    this.inputEl.removeEventListener(
      "input",
      this.onInputChanged.bind(this)
    );
    this.inputEl.removeEventListener(
      "focus",
      this.onInputChanged.bind(this)
    );
    this.inputEl.removeEventListener("blur", this.close.bind(this));
  }
};
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};

// src/settings/folder-suggest.ts
var FolderSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLocaleLowerCase();
    abstractFiles.forEach((folder) => {
      var _a;
      if (folder instanceof import_obsidian2.TFolder && ((_a = folder.path.toLocaleLowerCase()) == null ? void 0 : _a.contains(lowerCaseInputStr))) {
        folders.push(folder);
      }
    });
    return import_fuzzysort.default.go(lowerCaseInputStr, folders, {
      key: "path"
    });
  }
  renderSuggestion(file, el) {
    highlightSearch(el, file);
  }
  selectSuggestion(file) {
    var _a;
    this.inputEl.value = (_a = file.obj) == null ? void 0 : _a.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/file-suggest.ts
var import_fuzzysort2 = __toESM(require_fuzzysort());
var FileSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    let abstractFiles = this.app.vault.getAllLoadedFiles();
    const lowerCaseInputStr = inputStr.toLocaleLowerCase();
    abstractFiles = abstractFiles.filter((file) => {
      return file.path.endsWith(".md");
    });
    abstractFiles = abstractFiles.map((file) => {
      return {
        ...file,
        path: file.path.slice(0, -3)
      };
    });
    return import_fuzzysort2.default.go(lowerCaseInputStr, abstractFiles, {
      key: "path"
    });
  }
  renderSuggestion(file, el) {
    highlightSearch(el, file);
  }
  selectSuggestion(file) {
    var _a;
    this.inputEl.value = (_a = file.obj) == null ? void 0 : _a.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  triggerSymbol: "@",
  limitLinkDirectories: [],
  includeSymbol: true,
  showAddNewNote: false,
  addNewNoteTemplateFile: "",
  addNewNoteDirectory: "",
  useCompatibilityMode: false,
  leavePopupOpenForXSpaces: 0,
  // eslint-disable-next-line no-useless-escape
  invalidCharacterRegex: `[[]^|#]`,
  invalidCharacterRegexFlags: "i",
  removeAccents: true
};
var arrayMove = (array, fromIndex, toIndex) => {
  if (toIndex < 0 || toIndex === array.length) {
    return;
  }
  const temp = array[fromIndex];
  array[fromIndex] = array[toIndex];
  array[toIndex] = temp;
};
var SettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.shouldReset = false;
  }
  // On close, reload the plugin
  hide() {
    this.plugin.reloadPlugin(this.shouldReset);
    this.shouldReset = false;
  }
  display() {
    this.containerEl.empty();
    const triggerSymbolDesc = document.createDocumentFragment();
    triggerSymbolDesc.append("Type this symbol to trigger the popup.");
    new import_obsidian3.Setting(this.containerEl).setName("Trigger Symbol").setDesc(triggerSymbolDesc).addText((text) => {
      text.setPlaceholder("@").setValue(this.plugin.settings.triggerSymbol).onChange((value) => {
        this.plugin.settings.triggerSymbol = value;
        this.plugin.saveSettings();
      });
      text.inputEl.onblur = () => {
        this.display();
        this.validate();
      };
    });
    const includeSymbolDesc = document.createDocumentFragment();
    includeSymbolDesc.append(
      `Include the ${this.plugin.settings.triggerSymbol} symbol prefixing the final link text`,
      includeSymbolDesc.createEl("br"),
      includeSymbolDesc.createEl("em", {
        text: `E.g. [${this.plugin.settings.includeSymbol ? this.plugin.settings.triggerSymbol : ""}evan](./evan)`
      })
    );
    new import_obsidian3.Setting(this.containerEl).setName(`Include ${this.plugin.settings.triggerSymbol} symbol`).setDesc(includeSymbolDesc).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.includeSymbol).onChange((value) => {
        this.plugin.settings.includeSymbol = value;
        this.plugin.saveSettings();
        this.display();
      })
    );
    const ruleDesc = document.createDocumentFragment();
    ruleDesc.append(
      `${this.plugin.settings.triggerSymbol} linking will only source links from the following folders.`,
      ruleDesc.createEl("br"),
      `For example, you might only want contacts in the Contacts/ folder to be linked when you type ${this.plugin.settings.triggerSymbol}.`,
      ruleDesc.createEl("br"),
      ruleDesc.createEl("em", {
        text: "If no folders are added, links will be sourced from all folders."
      })
    );
    new import_obsidian3.Setting(this.containerEl).setName("Limit links to folders").setDesc(ruleDesc).addButton((button) => {
      button.setTooltip("Add limit folder").setButtonText("+").setCta().onClick(async () => {
        this.plugin.settings.limitLinkDirectories.push("");
        await this.plugin.saveSettings();
        return this.display();
      });
    });
    this.plugin.settings.limitLinkDirectories.forEach(
      (directory, index) => {
        const newDirectorySetting = new import_obsidian3.Setting(this.containerEl).setClass("at-symbol-linking-folder-container").addSearch((cb) => {
          new FolderSuggest(this.app, cb.inputEl);
          cb.setPlaceholder("Folder").setValue(directory).onChange(async (newFolder) => {
            this.plugin.settings.limitLinkDirectories[index] = newFolder.trim();
            await this.plugin.saveSettings();
          });
          cb.inputEl.onblur = () => {
            this.validate();
          };
        }).addExtraButton((cb) => {
          cb.setIcon("up-chevron-glyph").setTooltip("Move up").onClick(async () => {
            arrayMove(
              this.plugin.settings.limitLinkDirectories,
              index,
              index - 1
            );
            await this.plugin.saveSettings();
            this.display();
          });
        }).addExtraButton((cb) => {
          cb.setIcon("down-chevron-glyph").setTooltip("Move down").onClick(async () => {
            arrayMove(
              this.plugin.settings.limitLinkDirectories,
              index,
              index + 1
            );
            await this.plugin.saveSettings();
            this.display();
          });
        }).addExtraButton((cb) => {
          cb.setIcon("cross").setTooltip("Delete").onClick(async () => {
            this.plugin.settings.limitLinkDirectories.splice(
              index,
              1
            );
            await this.plugin.saveSettings();
            this.display();
          });
        });
        newDirectorySetting.controlEl.addClass(
          "at-symbol-linking-folder-setting"
        );
        newDirectorySetting.infoEl.remove();
      }
    );
    new import_obsidian3.Setting(this.containerEl).setName("Add new note").setHeading();
    new import_obsidian3.Setting(this.containerEl).setName("Add new note if it doesn't exist").setDesc(
      `If the note doesn't exist when ${this.plugin.settings.triggerSymbol} linking, add an option to create the note.`
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showAddNewNote).onChange((value) => {
        this.plugin.settings.showAddNewNote = value;
        this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.showAddNewNote) {
      const newNoteTemplateDesc = document.createDocumentFragment();
      newNoteTemplateDesc.append(
        `Template to use when creating a new note from ${this.plugin.settings.triggerSymbol} link.`,
        newNoteTemplateDesc.createEl("br"),
        "Uses formats from the ",
        newNoteTemplateDesc.createEl("a", {
          text: "core templates plugin",
          href: "https://help.obsidian.md/Plugins/Templates"
        }),
        " to replace the following variables in the template:",
        newNoteTemplateDesc.createEl("br"),
        newNoteTemplateDesc.createEl("code", {
          text: "{{title}}"
        }),
        " - The title of the new file",
        newNoteTemplateDesc.createEl("br"),
        newNoteTemplateDesc.createEl("code", {
          text: "{{date}}"
        }),
        " - The current date",
        newNoteTemplateDesc.createEl("br"),
        newNoteTemplateDesc.createEl("code", {
          text: "{{time}}"
        }),
        " - The current time"
      );
      new import_obsidian3.Setting(this.containerEl).setName("Add new note template").setDesc(newNoteTemplateDesc).addSearch((cb) => {
        new FileSuggest(this.app, cb.inputEl);
        cb.setPlaceholder("No template (blank note)").setValue(this.plugin.settings.addNewNoteTemplateFile).onChange(async (newFile) => {
          this.plugin.settings.addNewNoteTemplateFile = newFile.trim();
          await this.plugin.saveSettings();
        });
        cb.inputEl.onblur = () => {
          this.validate();
        };
      });
      new import_obsidian3.Setting(this.containerEl).setName("Add new note folder").setDesc(
        `Folder to create new notes in when using ${this.plugin.settings.triggerSymbol} linking.`
      ).addSearch((cb) => {
        new FolderSuggest(this.app, cb.inputEl);
        cb.setPlaceholder("No folder (root)").setValue(this.plugin.settings.addNewNoteDirectory).onChange(async (newFolder) => {
          this.plugin.settings.addNewNoteDirectory = newFolder.trim();
          await this.plugin.saveSettings();
        });
        cb.inputEl.onblur = () => {
          this.validate();
        };
      });
    }
    new import_obsidian3.Setting(this.containerEl).setName("Suggestion popup behavior").setHeading();
    const useCompatibilityModeDesc = document.createDocumentFragment();
    useCompatibilityModeDesc.append(
      useCompatibilityModeDesc.createEl("br"),
      "Renders an HTML popup in place of the native Obsidian popup.",
      useCompatibilityModeDesc.createEl("br"),
      "Useful if you other plugins are interfering with the popup (e.g. the Tasks plugin).",
      useCompatibilityModeDesc.createEl("br"),
      useCompatibilityModeDesc.createEl("em", {
        text: "May be slower than the native popup."
      })
    );
    new import_obsidian3.Setting(this.containerEl).setName("Use compatibility mode").setDesc(useCompatibilityModeDesc).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useCompatibilityMode).onChange((value) => {
        this.shouldReset = true;
        this.plugin.settings.useCompatibilityMode = value;
        this.plugin.saveSettings();
        this.plugin.registerPopup();
        this.display();
      })
    );
    const leavePopupOpenDesc = document.createDocumentFragment();
    leavePopupOpenDesc.append(
      `When ${this.plugin.settings.triggerSymbol} linking, you might want to type a full name e.g. "Brandon Sanderson" without the popup closing.`,
      leavePopupOpenDesc.createEl("br"),
      leavePopupOpenDesc.createEl("em", {
        text: "When set above 0, you'll need to press escape, return/enter, or type over X spaces to close the popup."
      })
    );
    new import_obsidian3.Setting(this.containerEl).setName("Leave popup open for X spaces").setDesc(leavePopupOpenDesc).addText((text) => {
      var _a;
      text.setPlaceholder("0").setValue(
        (_a = this.plugin.settings.leavePopupOpenForXSpaces) == null ? void 0 : _a.toString()
      ).onChange(async (value) => {
        this.plugin.settings.leavePopupOpenForXSpaces = parseInt(value, 10);
        await this.plugin.saveSettings();
      });
      text.inputEl.onblur = () => {
        this.validate();
      };
    });
    new import_obsidian3.Setting(this.containerEl).setName("Advanced settings").setHeading();
    const invalidCharacterRegexDesc = document.createDocumentFragment();
    invalidCharacterRegexDesc.append(
      invalidCharacterRegexDesc.createEl("br"),
      "Characters typed that match this regex will not be included in the final search query in compatibility mode.",
      invalidCharacterRegexDesc.createEl("br"),
      "In normal mode, the popup will close when an invalid character is typed."
    );
    new import_obsidian3.Setting(this.containerEl).setName("Invalid character Regex").setDesc(invalidCharacterRegexDesc).addText((text) => {
      text.setPlaceholder(this.plugin.settings.invalidCharacterRegex).setValue(this.plugin.settings.invalidCharacterRegex).onChange(async (value) => {
        this.plugin.settings.invalidCharacterRegex = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.onblur = () => {
        this.validate("invalidCharacterRegex");
      };
    });
    const invalidCharacterRegexFlagsDesc = document.createDocumentFragment();
    invalidCharacterRegexFlagsDesc.append(
      "Flags to use with the invalid character regex."
    );
    new import_obsidian3.Setting(this.containerEl).setName("Invalid character Regex flags").setDesc(invalidCharacterRegexFlagsDesc).addText((text) => {
      text.setPlaceholder(
        this.plugin.settings.invalidCharacterRegexFlags
      ).setValue(this.plugin.settings.invalidCharacterRegexFlags).onChange(async (value) => {
        this.plugin.settings.invalidCharacterRegexFlags = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.onblur = () => {
        this.validate("invalidCharacterRegexFlags");
      };
    });
    new import_obsidian3.Setting(this.containerEl).setName("Remove accents from search query").setDesc(
      "e.g. \xE9 -> e when searching or creating links via the popup."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.removeAccents).onChange((value) => {
        this.plugin.settings.removeAccents = value;
        this.plugin.saveSettings();
      })
    );
  }
  async validate(editedSetting) {
    var _a;
    const settings = this.plugin.settings;
    const updateSetting = async (setting, value) => {
      this.plugin.settings[setting] = value;
      await this.plugin.saveSettings();
      return this.display();
    };
    if (settings.triggerSymbol.length !== 1) {
      new import_obsidian3.Notice(`Trigger symbol must be a single character.`);
      await updateSetting(
        "triggerSymbol",
        settings.triggerSymbol.length ? settings.triggerSymbol[0] : "@"
      );
    }
    for (let i = 0; i < settings.limitLinkDirectories.length; i++) {
      const folder = settings.limitLinkDirectories[i];
      if (folder === "") {
        continue;
      }
      const folderFile = this.app.vault.getAbstractFileByPath(folder);
      if (!folderFile) {
        new import_obsidian3.Notice(
          `Unable to find folder at path: ${folder}. Please add it if you want to limit links to this folder.`
        );
        const newFolders = [...settings.limitLinkDirectories];
        newFolders[i] = "";
        await updateSetting("limitLinkDirectories", newFolders);
      }
    }
    if (settings.showAddNewNote && settings.addNewNoteTemplateFile) {
      const templateFile = this.app.vault.getAbstractFileByPath(
        `${settings.addNewNoteTemplateFile}.md`
      );
      if (!templateFile) {
        new import_obsidian3.Notice(
          `Unable to find template file at path: ${settings.addNewNoteTemplateFile}.md`
        );
        await updateSetting("addNewNoteTemplateFile", "");
      }
    }
    if (settings.showAddNewNote && settings.addNewNoteDirectory) {
      const templateFile = this.app.vault.getAbstractFileByPath(
        `${settings.addNewNoteDirectory}`
      );
      if (!templateFile) {
        new import_obsidian3.Notice(
          `Unable to find folder for new notes at path: ${settings.addNewNoteDirectory}. Please add it if you want to create new notes in this folder.`
        );
        await updateSetting("addNewNoteDirectory", "");
      }
    }
    if (isNaN(parseInt(settings.leavePopupOpenForXSpaces.toString())) || settings.leavePopupOpenForXSpaces < 0) {
      await updateSetting("leavePopupOpenForXSpaces", 0);
    }
    if (((_a = settings.invalidCharacterRegex) == null ? void 0 : _a.trim()) === "") {
      await updateSetting(
        "invalidCharacterRegex",
        DEFAULT_SETTINGS.invalidCharacterRegex
      );
    }
    try {
      new RegExp(
        settings.invalidCharacterRegex,
        settings.invalidCharacterRegexFlags
      );
    } catch (e) {
      new import_obsidian3.Notice(`Invalid regex or flags`);
      if (editedSetting === "invalidCharacterRegex") {
        await updateSetting(
          "invalidCharacterRegex",
          DEFAULT_SETTINGS.invalidCharacterRegex
        );
      } else if (editedSetting === "invalidCharacterRegexFlags") {
        await updateSetting(
          "invalidCharacterRegexFlags",
          DEFAULT_SETTINGS.invalidCharacterRegexFlags
        );
      }
    }
  }
};

// src/native-suggestion/suggest-popup.ts
var import_obsidian7 = require("obsidian");
var import_language = require("@codemirror/language");

// src/shared-suggestion/sharedSelectSuggestion.ts
var import_obsidian5 = require("obsidian");

// src/utils/replace-new-file-vars.ts
var import_obsidian4 = require("obsidian");
async function replaceNewFileVars(app2, templateContent, title) {
  if (!templateContent)
    return templateContent;
  const coreTemplatesConfigPath = ".obsidian/templates.json";
  let coreTemplatesConfig;
  try {
    coreTemplatesConfig = await app2.vault.adapter.read(
      coreTemplatesConfigPath
    );
    coreTemplatesConfig = JSON.parse(coreTemplatesConfig);
  } catch (error) {
    console.error(
      `@ Symbol Linking: Unable to read core plugin templates config at path: ${coreTemplatesConfigPath}`
    );
    console.log(error);
    return templateContent;
  }
  let dateFormat = "YYYY-MM-DD";
  let timeFormat = "HH:mm";
  if (coreTemplatesConfig == null ? void 0 : coreTemplatesConfig.dateFormat) {
    dateFormat = coreTemplatesConfig.dateFormat;
  }
  if (coreTemplatesConfig == null ? void 0 : coreTemplatesConfig.timeFormat) {
    timeFormat = coreTemplatesConfig.timeFormat;
  }
  templateContent = templateContent.replace(
    /{{date}}/g,
    (0, import_obsidian4.moment)().format(dateFormat)
  );
  templateContent = templateContent.replace(
    /{{time}}/g,
    (0, import_obsidian4.moment)().format(timeFormat)
  );
  templateContent = templateContent.replace(/{{title}}/g, title);
  return templateContent;
}

// src/utils/path.ts
function fileNameNoExtension(path) {
  var _a, _b;
  if (!path)
    return path;
  return (_b = (_a = path.split("/")) == null ? void 0 : _a.pop()) == null ? void 0 : _b.slice(0, -3);
}

// src/shared-suggestion/sharedSelectSuggestion.ts
async function sharedSelectSuggestion(app2, settings, value) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let linkFile;
  if ((_a = value == null ? void 0 : value.obj) == null ? void 0 : _a.isCreateNewOption) {
    let newNoteContents = "";
    if (settings.addNewNoteTemplateFile) {
      const fileTemplate = app2.vault.getAbstractFileByPath(
        `${settings.addNewNoteTemplateFile}.md`
      );
      newNoteContents = await app2.vault.read(fileTemplate) || "";
      newNoteContents = await replaceNewFileVars(
        app2,
        newNoteContents,
        fileNameNoExtension((_b = value.obj) == null ? void 0 : _b.filePath)
      );
    }
    try {
      linkFile = await app2.vault.create(
        (_c = value.obj) == null ? void 0 : _c.filePath,
        newNoteContents
      );
      value.obj.alias = (_d = value.obj) == null ? void 0 : _d.query;
    } catch (error) {
      new import_obsidian5.Notice(
        `Unable to create new note at path: ${(_e = value.obj) == null ? void 0 : _e.filePath}. Please open an issue on GitHub, https://github.com/Ebonsignori/obsidian-at-symbol-linking/issues`,
        0
      );
      throw error;
    }
  }
  const currentFile = app2.workspace.getActiveFile();
  if (!linkFile) {
    linkFile = app2.vault.getAbstractFileByPath(
      (_f = value.obj) == null ? void 0 : _f.filePath
    );
  }
  let alias = ((_g = value.obj) == null ? void 0 : _g.alias) || "";
  if (settings.includeSymbol)
    alias = `${settings.triggerSymbol}${alias || ((_h = value.obj) == null ? void 0 : _h.fileName)}`;
  let linkText = app2.fileManager.generateMarkdownLink(
    linkFile,
    (currentFile == null ? void 0 : currentFile.path) || "",
    void 0,
    // we don't care about the subpath
    alias
  );
  if (linkText.includes("\n")) {
    linkText = linkText.replace(/\n/g, "");
  }
  return linkText;
}

// src/shared-suggestion/sharedRenderSuggestion.ts
var import_obsidian6 = require("obsidian");
function sharedRenderSuggestion(value, el) {
  var _a, _b, _c, _d, _e, _f, _g;
  el.addClass("at-symbol-linking-suggestion");
  const context = el.doc.createElement("div");
  context.addClass("suggestion-context");
  context.id = "at-symbol-suggestion-context";
  const title = el.doc.createElement("div");
  title.addClass("suggestion-title");
  if (value[0]) {
    highlightSearch(title, value[0]);
  } else if ((_a = value.obj) == null ? void 0 : _a.alias) {
    title.setText((_b = value.obj) == null ? void 0 : _b.alias);
  } else if (value[1]) {
    highlightSearch(title, value[1]);
  } else if ((_c = value.obj) == null ? void 0 : _c.fileName) {
    title.setText((_d = value.obj) == null ? void 0 : _d.fileName);
  } else {
    title.setText("");
  }
  const path = el.doc.createElement("div");
  path.addClass("suggestion-path");
  path.setText((_f = (_e = value.obj) == null ? void 0 : _e.filePath) == null ? void 0 : _f.slice(0, -3));
  context.appendChild(title);
  context.appendChild(path);
  const aux = el.doc.createElement("div");
  aux.addClass("suggestion-aux");
  if ((_g = value == null ? void 0 : value.obj) == null ? void 0 : _g.alias) {
    const alias = el.doc.createElement("span");
    alias.addClass("suggestion-flair");
    alias.ariaLabel = "Alias";
    (0, import_obsidian6.setIcon)(alias, "forward");
    aux.appendChild(alias);
  }
  el.appendChild(context);
  el.appendChild(aux);
}

// src/shared-suggestion/sharedGetSuggestions.ts
var import_fuzzysort3 = __toESM(require_fuzzysort());

// src/utils/remove-accents.ts
function removeAccents(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

// src/shared-suggestion/sharedGetSuggestions.ts
function sharedGetSuggestions(files, query, settings) {
  var _a, _b;
  const options = [];
  for (const file of files) {
    if (settings.limitLinkDirectories.length > 0) {
      let isAllowed = false;
      for (const folder of settings.limitLinkDirectories) {
        if (file.path.startsWith(folder)) {
          isAllowed = true;
          break;
        }
      }
      if (!isAllowed) {
        continue;
      }
    }
    const meta = app.metadataCache.getFileCache(file);
    if ((_a = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _a.alias) {
      options.push({
        fileName: settings.removeAccents ? removeAccents(file.basename) : file.basename,
        filePath: file.path,
        alias: meta.frontmatter.alias
      });
    } else if ((_b = meta == null ? void 0 : meta.frontmatter) == null ? void 0 : _b.aliases) {
      let aliases = meta.frontmatter.aliases;
      if (typeof meta.frontmatter.aliases === "string") {
        aliases = meta.frontmatter.aliases.split(",").map((s) => s.trim());
      }
      for (const alias of aliases) {
        options.push({
          fileName: settings.removeAccents ? removeAccents(file.basename) : file.basename,
          filePath: file.path,
          alias: settings.removeAccents ? removeAccents(alias) : alias
        });
      }
    }
    options.push({
      fileName: settings.removeAccents ? removeAccents(file.basename) : file.basename,
      filePath: file.path
    });
  }
  let results = [];
  if (!query) {
    results = options.map((option) => ({
      obj: option
    })).reverse();
  } else {
    results = import_fuzzysort3.default.go(query, options, {
      keys: ["alias", "fileName"]
    });
  }
  if (settings.showAddNewNote && query) {
    const hasExistingNote = results.some(
      (result) => {
        var _a2;
        return ((_a2 = result == null ? void 0 : result.obj) == null ? void 0 : _a2.fileName.toLocaleLowerCase()) === (query == null ? void 0 : query.toLocaleLowerCase());
      }
    );
    if (!hasExistingNote) {
      results = results.filter(
        (result) => {
          var _a2;
          return !((_a2 = result.obj) == null ? void 0 : _a2.isCreateNewOption);
        }
      );
      const separator = settings.addNewNoteDirectory ? "/" : "";
      results.push({
        obj: {
          isCreateNewOption: true,
          query,
          fileName: "Create new note",
          filePath: `${settings.addNewNoteDirectory.trim()}${separator}${query.trim()}.md`
        }
      });
    }
  }
  return results;
}

// src/utils/valid-file-name.ts
var isValidFileNameCharacter = (char, settings) => {
  if (char === " ") {
    return true;
  }
  if (char === "\\") {
    return false;
  }
  return !new RegExp(
    settings.invalidCharacterRegex,
    settings.invalidCharacterRegexFlags
  ).test(char);
};

// src/native-suggestion/suggest-popup.ts
var SuggestionPopup = class extends import_obsidian7.EditorSuggest {
  constructor(app2, settings) {
    super(app2);
    this.firstOpenedCursor = null;
    this.focused = false;
    this.name = "@ Symbol Linking Suggest";
    this.app = app2;
    this.settings = settings;
    const self = this;
    self.scope.keys = [];
  }
  open() {
    super.open();
    this.focused = true;
  }
  close() {
    super.close();
    this.focused = false;
  }
  getSuggestions(context) {
    const files = context.file.vault.getMarkdownFiles();
    return sharedGetSuggestions(files, context.query, this.settings);
  }
  onTrigger(cursor, editor) {
    var _a, _b;
    let query = "";
    const typedChar = editor.getRange(
      { ...cursor, ch: cursor.ch - 1 },
      { ...cursor, ch: cursor.ch }
    );
    if (this.firstOpenedCursor && (typedChar === "\n" || typedChar === "	")) {
      return this.closeSuggestion();
    }
    let isInCodeBlock = false;
    if (editor == null ? void 0 : editor.cm) {
      const cm = editor.cm;
      const cursor2 = (_b = (_a = cm.state) == null ? void 0 : _a.selection) == null ? void 0 : _b.main;
      (0, import_language.syntaxTree)(cm.state).iterate({
        from: cursor2.from,
        to: cursor2.to,
        enter(node) {
          var _a2;
          if (node.type.name === "inline-code" || ((_a2 = node.type.name) == null ? void 0 : _a2.includes("codeblock"))) {
            isInCodeBlock = true;
          }
        }
      });
    }
    if (isInCodeBlock && !this.firstOpenedCursor) {
      return null;
    }
    if (typedChar === this.settings.triggerSymbol) {
      this.firstOpenedCursor = cursor;
      return {
        start: { ...cursor, ch: cursor.ch - 1 },
        end: cursor,
        query
      };
    }
    if (!this.firstOpenedCursor) {
      return null;
    } else {
      query = editor.getRange(this.firstOpenedCursor, {
        ...cursor,
        ch: cursor.ch
      });
    }
    if (query.split(" ").length - 1 > this.settings.leavePopupOpenForXSpaces || // Also close if query starts with a space, regardless of space settings
    query.startsWith(" ")) {
      return this.closeSuggestion();
    }
    if (!query || !isValidFileNameCharacter(typedChar, this.settings)) {
      return this.closeSuggestion();
    }
    return {
      start: { ...cursor, ch: cursor.ch - 1 },
      end: cursor,
      query: this.settings.removeAccents ? removeAccents(query) : query
    };
  }
  renderSuggestion(value, el) {
    sharedRenderSuggestion(value, el);
  }
  async selectSuggestion(value) {
    var _a, _b;
    const line = ((_a = this.context) == null ? void 0 : _a.editor.getRange(
      {
        line: this.context.start.line,
        ch: 0
      },
      this.context.end
    )) || "";
    const linkText = await sharedSelectSuggestion(
      this.app,
      this.settings,
      value
    );
    (_b = this.context) == null ? void 0 : _b.editor.replaceRange(
      linkText,
      {
        line: this.context.start.line,
        ch: line.lastIndexOf(this.settings.triggerSymbol)
      },
      this.context.end
    );
    this.closeSuggestion();
  }
  selectNextItem(dir) {
    if (!this.focused) {
      this.focused = true;
      dir = dir === SelectionDirection.PREVIOUS ? dir : SelectionDirection.NONE;
    }
    const self = this;
    self.suggestions.setSelectedItem(
      self.suggestions.selectedItem + dir,
      new KeyboardEvent("keydown")
    );
  }
  closeSuggestion() {
    this.firstOpenedCursor = null;
    this.close();
    return null;
  }
  getSelectedItem() {
    const self = this;
    return self.suggestions.values[self.suggestions.selectedItem];
  }
  applySelectedItem() {
    const self = this;
    self.suggestions.useSelectedItem();
  }
  isVisible() {
    return this.isOpen;
  }
  isFocused() {
    return this.focused;
  }
};
var SelectionDirection = /* @__PURE__ */ ((SelectionDirection2) => {
  SelectionDirection2[SelectionDirection2["NEXT"] = 1] = "NEXT";
  SelectionDirection2[SelectionDirection2["PREVIOUS"] = -1] = "PREVIOUS";
  SelectionDirection2[SelectionDirection2["NONE"] = 0] = "NONE";
  return SelectionDirection2;
})(SelectionDirection || {});

// src/native-suggestion/hotkeys.ts
function applyHotKeyHack(_this, app2) {
  app2.scope.keys = [];
  const isHotkeyMatch = (hotkey, context, isBypassCommand) => {
    var _a;
    const modifiers = hotkey.modifiers, key = hotkey.key;
    if (modifiers !== null && (isBypassCommand ? !((_a = context == null ? void 0 : context.modifiers) == null ? void 0 : _a.contains(modifiers)) : modifiers !== context.modifiers))
      return false;
    return !key || key === context.vkey || !(!context.key || key.toLocaleLowerCase() !== context.key.toLocaleLowerCase());
  };
  _this.app.scope.register(
    null,
    null,
    (e, t) => {
      var _a, _b;
      const hotkeyManager = app2.hotkeyManager;
      hotkeyManager.bake();
      for (let bakedHotkeys = hotkeyManager.bakedHotkeys, bakedIds = hotkeyManager.bakedIds, r = 0; r < bakedHotkeys.length; r++) {
        const hotkey = bakedHotkeys[r];
        const id = bakedIds[r];
        const command = app2.commands.findCommand(id);
        const isBypassCommand = (_a = command == null ? void 0 : command.isBypassCommand) == null ? void 0 : _a.call(command);
        if (isHotkeyMatch(hotkey, t, isBypassCommand)) {
          if (!command || e.repeat && !command.repeatable) {
            continue;
          } else if (command.isVisible && !command.isVisible()) {
            continue;
          } else if (isBypassCommand) {
            _this._suggestionPopup.close();
            const validMods = t.modifiers.replace(new RegExp(`${hotkey.modifiers},*`), "").split(",");
            const event = new KeyboardEvent("keydown", {
              key: hotkeyManager.defaultKeys[id][0].key,
              ctrlKey: validMods == null ? void 0 : validMods.contains("Ctrl"),
              shiftKey: validMods == null ? void 0 : validMods.contains("Shift"),
              altKey: validMods == null ? void 0 : validMods.contains("Alt"),
              metaKey: validMods == null ? void 0 : validMods.contains("Meta")
            });
            (_b = e == null ? void 0 : e.target) == null ? void 0 : _b.dispatchEvent(event);
            return false;
          }
          if (app2.commands.executeCommandById(id))
            return false;
        }
      }
    }
  );
  _this.addCommand({
    id: "select-next-suggestion",
    name: "Select next suggestion",
    hotkeys: [
      {
        key: "ArrowDown",
        modifiers: []
      }
    ],
    repeatable: true,
    editorCallback: () => {
      _this._suggestionPopup.selectNextItem(1 /* NEXT */);
    },
    isVisible: () => {
      var _a;
      return (_a = _this._suggestionPopup) == null ? void 0 : _a.isVisible();
    }
  });
  _this.addCommand({
    id: "select-previous-suggestion",
    name: "Select previous suggestion",
    hotkeys: [
      {
        key: "ArrowUp",
        modifiers: []
      }
    ],
    repeatable: true,
    editorCallback: () => {
      _this._suggestionPopup.selectNextItem(-1 /* PREVIOUS */);
    },
    isVisible: () => {
      var _a;
      return (_a = _this._suggestionPopup) == null ? void 0 : _a.isVisible();
    }
  });
  _this.addCommand({
    id: "insert-selected-suggestion",
    name: "Insert selected suggestion",
    hotkeys: [
      {
        key: "Enter",
        modifiers: []
      }
    ],
    editorCallback: () => _this._suggestionPopup.applySelectedItem(),
    isVisible: () => {
      var _a;
      return (_a = _this._suggestionPopup) == null ? void 0 : _a.isVisible();
    }
  });
  _this.addCommand({
    id: "exit-suggestion",
    name: "Exit suggestions",
    hotkeys: [
      {
        key: "Escape",
        modifiers: []
      }
    ],
    editorCallback: () => _this._suggestionPopup.closeSuggestion(),
    isVisible: () => {
      var _a;
      return (_a = _this._suggestionPopup) == null ? void 0 : _a.isVisible();
    }
  });
}

// src/compatibility-mode-extension/extension-handler.ts
var import_language2 = require("@codemirror/language");
var import_view = require("@codemirror/view");
var import_obsidian9 = require("obsidian");

// src/compatibility-mode-extension/extension-popup.ts
var import_obsidian8 = require("obsidian");
var Suggest2 = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround2(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var LinkSuggest = class {
  constructor(app2, inputEl, settings, onSelect) {
    this.app = app2;
    this.inputEl = inputEl;
    this.settings = settings;
    this.scope = new import_obsidian8.Scope();
    this.onSelect = onSelect;
    this.suggestEl = createDiv("suggestion-container");
    if (import_obsidian8.Platform.isMobile) {
      this.suggestEl.style.padding = "0";
    } else {
      this.suggestEl.addClass("extension-container-at-symbol-linking");
    }
    this.suggestEl.style.zIndex = "1000";
    const suggestion = this.suggestEl.createDiv("suggestion");
    suggestion.id = "at-symbol-suggestion-container";
    this.suggest = new Suggest2(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged(inputStr) {
    const suggestions = this.getSuggestions(inputStr);
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: import_obsidian8.Platform.isMobile ? "top" : "bottom-start",
      modifiers: [
        {
          name: "flip",
          options: {
            flipVariations: false,
            fallbackPlacements: [
              import_obsidian8.Platform.isMobile ? "top" : "right"
            ]
          }
        },
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = import_obsidian8.Platform.isMobile ? "100vw" : `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    var _a;
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    (_a = this.popper) == null ? void 0 : _a.destroy();
    this.suggestEl.detach();
    this.inputEl.removeEventListener(
      "focus",
      this.onInputChanged.bind(this)
    );
    this.inputEl.removeEventListener("blur", this.close.bind(this));
  }
  getSuggestions(query) {
    const files = this.app.vault.getMarkdownFiles();
    return sharedGetSuggestions(files, query, this.settings);
  }
  renderSuggestion(value, el) {
    sharedRenderSuggestion(value, el);
  }
  async selectSuggestion(value) {
    const linkText = await sharedSelectSuggestion(
      this.app,
      this.settings,
      value
    );
    this.onSelect(linkText);
  }
};
var wrapAround2 = (value, size) => {
  return (value % size + size) % size;
};

// src/compatibility-mode-extension/extension-handler.ts
var maxParentDepth = 5;
function atSymbolTriggerExtension(app2, settings) {
  return import_view.ViewPlugin.fromClass(
    class AtSymbolTriggerExtension {
      constructor(view) {
        this.firstOpenedCursor = null;
        this.openQuery = "";
        this.isOpen = false;
        this.suggestionEl = null;
        this.suggestionPopup = null;
        this.view = view;
        this.handleKeyEvent = this.handleKeyEvent.bind(this);
        this.handleClickEvent = this.handleClickEvent.bind(this);
        window.addEventListener("click", this.handleClickEvent);
        this.view.dom.addEventListener("keydown", this.handleKeyEvent);
      }
      destroy() {
        this.view.dom.removeEventListener(
          "keydown",
          this.handleKeyEvent
        );
        window.removeEventListener("click", this.handleClickEvent);
      }
      closeSuggestion() {
        var _a, _b;
        this.isOpen = false;
        this.firstOpenedCursor = null;
        this.openQuery = "";
        (_a = this.suggestionPopup) == null ? void 0 : _a.close();
        (_b = this.suggestionEl) == null ? void 0 : _b.remove();
        this.suggestionPopup = null;
        this.suggestionEl = null;
        return true;
      }
      openSuggestion() {
        this.isOpen = true;
        this.firstOpenedCursor = this.getCursor();
        return true;
      }
      handleKeyEvent(event) {
        var _a, _b, _c, _d, _e, _f, _g;
        let isInTitle = false;
        (((_a = event.target) == null ? void 0 : _a.classList) || []).forEach((className) => {
          isInTitle = isInTitle || className === "inline-title";
        });
        if (isInTitle) {
          return false;
        }
        const typedChar = event.key;
        if (this.isOpen && (typedChar === "\n" || typedChar === "	")) {
          return this.closeSuggestion();
        }
        let isInValidContext = true;
        const cursor = (_d = (_c = (_b = this.view) == null ? void 0 : _b.viewState.state) == null ? void 0 : _c.selection) == null ? void 0 : _d.main;
        (0, import_language2.syntaxTree)((_f = (_e = this.view) == null ? void 0 : _e.viewState) == null ? void 0 : _f.state).iterate({
          from: cursor.from,
          to: cursor.to,
          enter(node) {
            var _a2;
            if (node.type.name === "hmd-frontmatter" || node.type.name === "inline-code" || ((_a2 = node.type.name) == null ? void 0 : _a2.includes("codeblock"))) {
              isInValidContext = false;
            }
          }
        });
        if (!isInValidContext) {
          return false;
        }
        let justOpened = false;
        if (!this.isOpen && typedChar === settings.triggerSymbol) {
          justOpened = true;
          this.openSuggestion();
        } else if (!this.isOpen) {
          return false;
        }
        const key = event.key.toLocaleLowerCase();
        if (typedChar === "Backspace") {
          if (this.openQuery.length === 0) {
            return this.closeSuggestion();
          }
          this.openQuery = this.openQuery.slice(0, -1);
        } else if (typedChar === "Escape") {
          this.closeSuggestion();
        } else if (!isValidFileNameCharacter(typedChar, settings) || event.altKey || event.metaKey || event.ctrlKey || key.includes("backspace") || key.includes("shift") || key.includes("arrow")) {
          return false;
        } else if (!justOpened) {
          this.openQuery += typedChar;
        }
        if (this.openQuery.split(" ").length - 1 > settings.leavePopupOpenForXSpaces || // Also close if the query starts with a space, regardless of space settings
        this.openQuery.startsWith(" ")) {
          return this.closeSuggestion();
        }
        if (settings.removeAccents) {
          this.openQuery = removeAccents(this.openQuery);
        }
        if (!this.suggestionEl && this.firstOpenedCursor && this.view) {
          const container = app2.dom.appContainerEl;
          this.suggestionEl = createDiv();
          this.suggestionEl.style.position = "absolute";
          this.suggestionEl.style.zIndex = "1000";
          this.suggestionEl.id = "at-symbol-suggestion-root";
          this.suggestionEl.style.width = "0px";
          this.suggestionEl.style.height = "0px";
          if (import_obsidian9.Platform.isDesktop) {
            const { left: leftOffset, top: topOffset } = this.view.coordsAtPos(
              (_g = this.firstOpenedCursor) == null ? void 0 : _g.ch
            );
            this.suggestionEl.style.left = leftOffset + "px";
            const lineElementHeight = 24;
            this.suggestionEl.style.top = topOffset + lineElementHeight + "px";
          } else {
            this.suggestionEl.style.bottom = "var(--mobile-toolbar-height)";
            this.suggestionEl.style.left = "0px";
          }
          container.appendChild(this.suggestionEl);
          this.suggestionPopup = new LinkSuggest(
            app2,
            this.suggestionEl,
            settings,
            this.onSelect.bind(this)
          );
          this.suggestionPopup.onInputChanged(this.openQuery);
        }
        if (this.suggestionPopup) {
          this.suggestionPopup.onInputChanged(this.openQuery);
        }
        return true;
      }
      handleClickEvent(event) {
        if (this.isOpen) {
          let currentDepth = 0;
          let parent = event.target;
          let shouldClose = true;
          while (event.target && currentDepth < maxParentDepth) {
            currentDepth++;
            if ((parent == null ? void 0 : parent.id) === "at-symbol-suggestion-context") {
              shouldClose = false;
              break;
            }
            parent = parent == null ? void 0 : parent.parentNode;
          }
          if (shouldClose) {
            this.closeSuggestion();
          }
        }
      }
      onSelect(linkText) {
        var _a, _b;
        const cursor = this.getCursor();
        try {
          this.view.dispatch(
            this.view.state.update({
              changes: {
                from: (_a = this.firstOpenedCursor) == null ? void 0 : _a.ch,
                to: cursor.ch,
                insert: linkText
              }
            })
          );
        } catch (error) {
          console.log(
            "@ Symbol Linking: Error creating first link",
            error
          );
          this.view.dispatch(
            this.view.state.update({
              changes: {
                from: (_b = this.firstOpenedCursor) == null ? void 0 : _b.ch,
                insert: linkText
              }
            })
          );
        }
        this.closeSuggestion();
      }
      getCursor() {
        const ch = this.view.state.selection.ranges[0].head;
        const line = this.view.state.doc.lineAt(ch).number;
        return {
          ch,
          line
        };
      }
    }
  );
}

// src/main.ts
var AtSymbolLinking = class extends import_obsidian10.Plugin {
  constructor() {
    super(...arguments);
    this.reloadingPlugins = false;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.registerPopup();
  }
  // If compatibility mode is enabled, use the HTML extension-based popup
  // Otherwise, use the native EditorSuggest popup
  registerPopup() {
    if (this.settings.useCompatibilityMode) {
      this.activeExtensions = [
        atSymbolTriggerExtension(this.app, this.settings)
      ];
      this.registerEditorExtension(this.activeExtensions);
      this.registerEvent(
        this.app.workspace.on(
          "active-leaf-change",
          this.updateEditorProcessors.bind(this)
        )
      );
    } else {
      this._suggestionPopup = new SuggestionPopup(
        this.app,
        this.settings
      );
      this.registerEditorSuggest(this._suggestionPopup);
      applyHotKeyHack(this, this.app);
    }
  }
  // Since we can disable/enable modes that register and unregister an editor extension in settings
  // We need to reload the plugin to unregister the existing extension when settings are changed
  async reloadPlugin(shouldReset) {
    var _a;
    if (!shouldReset) {
      return;
    }
    if (this.reloadingPlugins)
      return;
    this.reloadingPlugins = true;
    const plugins = this.app.plugins;
    if (!((_a = plugins == null ? void 0 : plugins.enabledPlugins) == null ? void 0 : _a.has(this.manifest.id))) {
      return;
    }
    await plugins.disablePlugin(this.manifest.id);
    try {
      await new Promise((resolve) => setTimeout(resolve, 100));
      await plugins.enablePlugin(this.manifest.id);
    } catch (error) {
    }
    this.reloadingPlugins = false;
  }
  updateEditorProcessors() {
    var _a;
    if ((_a = this.activeExtensions) == null ? void 0 : _a.length) {
      this.activeExtensions.forEach((extension) => {
        if (typeof (extension == null ? void 0 : extension.destroy) === "function") {
          extension.destroy();
        }
      });
      this.activeExtensions.length = 0;
      this.activeExtensions.push(
        atSymbolTriggerExtension(this.app, this.settings)
      );
      this.app.workspace.updateOptions();
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */