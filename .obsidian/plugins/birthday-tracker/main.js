/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BirthdayTrackerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/birthday.ts
var Birthday = class {
  constructor(birthdayAsString, dateFormatter) {
    this.birthdayAsString = birthdayAsString;
    this.date = dateFormatter.parseToDate(birthdayAsString);
    this.age = this.determineAge();
    this.daysTillNextBirthday = this.calcDaysTillNextBirthday();
  }
  determineAge() {
    let age = (/* @__PURE__ */ new Date()).getFullYear() - this.date.getFullYear();
    return this.hadBirthdayThisYear() ? age : --age;
  }
  hadBirthdayThisYear() {
    const monthPassed = (/* @__PURE__ */ new Date()).getMonth() > this.date.getMonth();
    const daysPassed = (/* @__PURE__ */ new Date()).getMonth() === this.date.getMonth() && (/* @__PURE__ */ new Date()).getDate() >= this.date.getDate();
    return monthPassed || daysPassed;
  }
  calcDaysTillNextBirthday() {
    const days = this.calcDays((/* @__PURE__ */ new Date()).getFullYear());
    if (-days === 0) {
      return 0;
    }
    return days > 0 ? days : this.calcDays((/* @__PURE__ */ new Date()).getFullYear() + 1);
  }
  calcDays(newYear) {
    const dateCurrentYear = new Date(this.date);
    dateCurrentYear.setFullYear(newYear);
    const timeDifference = (/* @__PURE__ */ new Date()).getTime() - dateCurrentYear.getTime();
    return -Math.ceil(timeDifference / (1e3 * 60 * 60 * 24));
  }
  compareTo(other) {
    return this.daysTillNextBirthday - other.daysTillNextBirthday;
  }
  hasBirthdayToday() {
    return this.daysTillNextBirthday === 0;
  }
  getAge() {
    return this.age;
  }
  getDaysTillNextBirthday() {
    return this.daysTillNextBirthday;
  }
  getMonth() {
    return this.date.getMonth();
  }
  toString() {
    return this.birthdayAsString;
  }
};

// src/dateFormatter.ts
var _DefaultDateFormatter = class _DefaultDateFormatter {
  constructor(format) {
    this.format = format;
    this.dayIndex = format.search(_DefaultDateFormatter.DAY_IDENTIFIER);
    this.monthIndex = format.search(_DefaultDateFormatter.MONTH_IDENTIFIER);
    this.yearIndex = format.search(_DefaultDateFormatter.YEAR_IDENTIFIER);
  }
  static createFormat(format) {
    return _DefaultDateFormatter.isValidFormat(format) ? new _DefaultDateFormatter(format) : void 0;
  }
  static isValidFormat(format) {
    const containsDay = _DefaultDateFormatter.formatContains(
      _DefaultDateFormatter.DAY_IDENTIFIER,
      format
    );
    const containsMonth = _DefaultDateFormatter.formatContains(
      _DefaultDateFormatter.MONTH_IDENTIFIER,
      format
    );
    const containsYear = _DefaultDateFormatter.formatContains(
      _DefaultDateFormatter.YEAR_IDENTIFIER,
      format
    );
    return containsDay && containsMonth && containsYear && !_DefaultDateFormatter.containsInvalidChars(format);
  }
  static formatContains(subStr, format) {
    return format.includes(subStr) || format.includes(subStr.toLowerCase());
  }
  static containsInvalidChars(format) {
    const invalidChars = [
      "A",
      "B",
      "C",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Z",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    for (const invalidChar in invalidChars) {
      if (_DefaultDateFormatter.formatContains(invalidChar, format)) {
        return true;
      }
    }
    return false;
  }
  parseToDate(dateAsString) {
    const date = /* @__PURE__ */ new Date();
    const year = this.extractComponentOfDate(dateAsString, {
      start: this.yearIndex,
      end: this.yearIndex + _DefaultDateFormatter.YEAR_IDENTIFIER.length
    });
    const month = this.extractComponentOfDate(dateAsString, {
      start: this.monthIndex,
      end: this.monthIndex + _DefaultDateFormatter.MONTH_IDENTIFIER.length,
      offset: 1
      // needed offset cause Date API returns wrong month of date => WHYYY???
    });
    const day = this.extractComponentOfDate(dateAsString, {
      start: this.dayIndex,
      end: this.dayIndex + _DefaultDateFormatter.DAY_IDENTIFIER.length
    });
    date.setFullYear(year, month, day);
    return date;
  }
  extractComponentOfDate(dateAsString, range) {
    var _a;
    return Number.parseInt(dateAsString.substring(range.start, range.end)) - ((_a = range.offset) != null ? _a : 0);
  }
};
_DefaultDateFormatter.DAY_IDENTIFIER = "DD";
_DefaultDateFormatter.MONTH_IDENTIFIER = "MM";
_DefaultDateFormatter.YEAR_IDENTIFIER = "YYYY";
var DefaultDateFormatter = _DefaultDateFormatter;

// src/modals/SearchPersonModal.ts
var import_obsidian2 = require("obsidian");

// src/modals/PersonModal.ts
var import_obsidian = require("obsidian");
var PersonModal = class extends import_obsidian.Modal {
  constructor(app, person) {
    super(app);
    this.person = person;
  }
  onOpen() {
    const { contentEl } = this;
    const div = contentEl.createDiv({
      cls: "personContainer smallerScale"
    });
    div.createEl("p", {
      text: `Name: ${this.person.name} (${this.person.age})`
    });
    div.createEl("p", {
      text: `Days next birthday: ${this.person.daysTillNextBirthday}`
    });
    div.createEl("p", { text: `Birthday: ${this.person.birthday}` });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/SearchPersonModal.ts
var SearchPersonModal = class extends import_obsidian2.FuzzySuggestModal {
  constructor(app, persons) {
    super(app);
    this.persons = persons;
  }
  getItems() {
    return this.persons;
  }
  getItemText(item) {
    return item.name;
  }
  onChooseItem(item, evt) {
    new PersonModal(this.app, item).open();
  }
};

// src/person.ts
var Person = class {
  constructor(name, birthday) {
    this.name = name;
    this.birthday = birthday;
  }
  compareTo(other) {
    return this.birthday.compareTo(other.birthday);
  }
  hasBirthdayToday() {
    return this.birthday.hasBirthdayToday();
  }
  toDTO() {
    return new PersonDTO(
      this.name,
      this.birthday.toString(),
      this.birthday.getDaysTillNextBirthday(),
      this.birthday.getAge(),
      this.birthday.getMonth()
    );
  }
};
var PersonDTO = class {
  constructor(name, birthday, daysTillNextBirthday, age, month) {
    this.name = name;
    this.birthday = birthday;
    this.daysTillNextBirthday = daysTillNextBirthday;
    this.age = age;
    this.month = month;
  }
};

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  dateFormatting: "DD/MM/YYYY",
  birthdayNodeLocation: "birthdayNode.md",
  automaticallyOpenBirthdayViewOnStart: true
};
var BirthdayTrackerSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.dateFormattingSettingsOnChange = async (value) => {
      let noticeMessage = "Wrong date formatting!!";
      const dateFormatter = DefaultDateFormatter.createFormat(value);
      if (dateFormatter) {
        this.plugin.settings.dateFormatting = dateFormatter.format;
        await this.plugin.saveSettings();
        noticeMessage = "Valid date formatting";
      }
      new import_obsidian3.Notice(noticeMessage);
    };
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    this.dateFormattingSettings();
    this.birthdayNodeLocationSettings();
    this.automaticallyOpenBirthdayViewOnStartSettings();
  }
  dateFormattingSettings() {
    return new import_obsidian3.Setting(this.containerEl).setName("Date formatting").setDesc("Format your dates will be displayed and collected").addText(
      (text) => text.setPlaceholder("Enter your format").setValue(this.plugin.settings.dateFormatting).onChange(async (v) => await this.dateFormattingSettingsOnChange(v))
    );
  }
  birthdayNodeLocationSettings() {
    return new import_obsidian3.Setting(this.containerEl).setName("Birthday node location").setDesc(
      "Location of your Node containing the birthday data with .md as postfix"
    ).addTextArea(
      (text) => text.setPlaceholder("Enter the node location").setValue(this.plugin.settings.birthdayNodeLocation).onChange(async (value) => {
        this.plugin.settings.birthdayNodeLocation = value;
        await this.plugin.saveSettings();
      })
    );
  }
  automaticallyOpenBirthdayViewOnStartSettings() {
    return new import_obsidian3.Setting(this.containerEl).setName("Automatically open birthday view on startup").setDesc(
      "If enabled, the birthday view is automatically opened in the right leaf when Obsidian starts"
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.automaticallyOpenBirthdayViewOnStart).onChange(async (value) => {
        this.plugin.settings.automaticallyOpenBirthdayViewOnStart = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/views/birthdayTrackerView.ts
var import_obsidian4 = require("obsidian");
var BIRTHDAY_TRACKER_VIEW_TYPE = "Birthday-Tracker";
var BirthdayTrackerView = class extends import_obsidian4.ItemView {
  constructor() {
    super(...arguments);
    this.icon = "cake";
  }
  getViewType() {
    return BIRTHDAY_TRACKER_VIEW_TYPE;
  }
  getDisplayText() {
    return BIRTHDAY_TRACKER_VIEW_TYPE;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Birthday Tracker" });
    this.container = contentEl.createDiv({ cls: "personsFlexboxContainer" });
  }
  displayPersons(persons) {
    while (this.container.firstChild) {
      this.container.removeChild(this.container.lastChild);
    }
    persons.forEach((person) => this.displayPerson(person.toDTO()));
  }
  displayPerson(person) {
    const div = this.container.createDiv({
      cls: "personContainer"
    });
    div.createEl("p", {
      text: `Name: ${person.name} (${person.age})`
    });
    div.createEl("p", {
      text: `Days next birthday: ${person.daysTillNextBirthday}`
    });
    div.createEl("p", { text: `Birthday: ${person.birthday}` });
  }
};

// src/views/yearOverviewView.ts
var import_obsidian5 = require("obsidian");
var BIRTHDAY_TRACKER_YEAR_OVERVIEW_VIEW_TYPE = "Birthday-Tracker-Year-Overview";
var MONTHS = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var YearOverviewView = class extends import_obsidian5.ItemView {
  constructor() {
    super(...arguments);
    this.icon = "calendar-days";
    this.persons = [];
    this.createPerson = (person, personContainer) => {
      const para = personContainer.createEl("p", { text: person.name });
      para.onclick = () => new PersonModal(this.app, person).open();
    };
  }
  getViewType() {
    return BIRTHDAY_TRACKER_YEAR_OVERVIEW_VIEW_TYPE;
  }
  getDisplayText() {
    return BIRTHDAY_TRACKER_YEAR_OVERVIEW_VIEW_TYPE;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Birthday Tracker - Year Overview" });
    const container = contentEl.createDiv({ cls: "yearContainer" });
    for (let i = 0; i < 12; i++) {
      const month = container.createDiv({ cls: "monthContainer" });
      month.createEl("h4", { text: MONTHS[i], cls: "monthName" });
      const personContainer = month.createDiv({
        cls: "personsYearViewContainer"
      });
      if (this.persons.length === 0) {
        continue;
      }
      for (const person of this.persons) {
        if (person.month === i) {
          this.createPerson(person, personContainer);
        }
      }
    }
  }
  async updatePersons(persons) {
    this.persons = persons;
    const { contentEl } = this;
    contentEl.empty();
    await this.onOpen();
  }
};

// src/main.ts
var BirthdayTrackerPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.trackBirthdays = async () => await this.trackBirthdaysWithOpenOption(true);
    this.trackBirthdaysWithOpenOption = async (shouldOpenView) => {
      const content = await this.fetchContent();
      if (content) {
        this.trackBirthdaysOfContent(content);
        if (shouldOpenView) {
          await this.openBirthdayView();
        }
      } else {
        new import_obsidian6.Notice("Nothing inside your node");
      }
    };
    this.trackBirthdaysOfContent = (content) => {
      this.persons = this.collectPersons(content);
      this.persons.sort((p1, p2) => p1.compareTo(p2));
      this.noticeIfBirthdayToday(this.persons);
    };
    this.lineContainsPerson = (line) => {
      return line.contains("name=") && line.contains("birthday=");
    };
    this.openYearView = async () => {
      const leaves = this.app.workspace.getLeavesOfType(
        BIRTHDAY_TRACKER_YEAR_OVERVIEW_VIEW_TYPE
      );
      if (leaves.length === 0) {
        leaves[0] = this.app.workspace.getLeaf(false);
        await leaves[0].setViewState({
          type: BIRTHDAY_TRACKER_YEAR_OVERVIEW_VIEW_TYPE
        });
      }
      const persons = await this.getPersons();
      await leaves[0].view.updatePersons(
        persons.map((p) => p.toDTO())
      );
      this.app.workspace.revealLeaf(leaves[0]);
    };
    this.searchPerson = async () => {
      await this.fetchContent();
      if (this.persons.length >= 1) {
        new SearchPersonModal(
          this.app,
          this.persons.map((person) => person.toDTO())
        ).open();
      } else {
        new import_obsidian6.Notice("No persons were found");
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      BIRTHDAY_TRACKER_VIEW_TYPE,
      (leaf) => new BirthdayTrackerView(leaf)
    );
    this.registerView(
      BIRTHDAY_TRACKER_YEAR_OVERVIEW_VIEW_TYPE,
      (leaf) => new YearOverviewView(leaf)
    );
    const ribbonIconEl = this.addRibbonIcon(
      "cake",
      "Track birthdays",
      this.trackBirthdays
    );
    ribbonIconEl.addClass("birthday-tracker-plugin-ribbon-class");
    this.addRibbonIcon(
      "calendar-days",
      "Open year overview",
      this.openYearView
    );
    this.addCommands();
    this.addSettingTab(new BirthdayTrackerSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(
      async () => await this.trackBirthdaysWithOpenOption(
        this.settings.automaticallyOpenBirthdayViewOnStart
      )
    );
  }
  addCommands() {
    this.addCommand({
      id: "track-birthdays",
      name: "Track Birthdays",
      callback: this.trackBirthdays
    });
    this.addCommand({
      id: "search-person",
      name: "Search Person",
      callback: this.searchPerson
    });
    this.addCommand({
      id: "year-overview",
      name: "Year Overview",
      callback: this.openYearView
    });
  }
  onunload() {
  }
  async fetchContent() {
    const file = this.app.vault.getAbstractFileByPath(
      this.settings.birthdayNodeLocation
    );
    if (file && file instanceof import_obsidian6.TFile) {
      return (await this.app.vault.read(file)).trim();
    }
    new import_obsidian6.Notice(
      `Node could not be found at location: ${this.settings.birthdayNodeLocation}`
    );
    return void 0;
  }
  collectPersons(content) {
    const persons = [];
    content.split(/\r?\n/).forEach((line) => {
      var _a, _b, _c, _d, _e, _f;
      if (this.lineContainsPerson(line)) {
        const splittedLine = line.split(";");
        const name = (_c = (_b = (_a = splittedLine[0]) == null ? void 0 : _a.trim().split("=").last()) == null ? void 0 : _b.trim()) != null ? _c : "";
        const birthdayAsString = (_f = (_e = (_d = splittedLine[1]) == null ? void 0 : _d.replace(" ", "").split("=").last()) == null ? void 0 : _e.trim()) != null ? _f : "";
        const birthday = new Birthday(
          birthdayAsString,
          // biome-ignore lint/style/noNonNullAssertion: Should work, because this check is already done before in settings.ts when dateFormatting is updated
          DefaultDateFormatter.createFormat(this.settings.dateFormatting)
        );
        persons.push(new Person(name, birthday));
      }
    });
    return persons;
  }
  noticeIfBirthdayToday(persons) {
    const personsBirthdayToday = persons.filter(
      (person) => person.hasBirthdayToday()
    );
    if (personsBirthdayToday.length !== 0) {
      this.noticeForAllBirthdaysToday(personsBirthdayToday);
    }
  }
  noticeForAllBirthdaysToday(personsBirthdayToday) {
    let message = "Today ";
    personsBirthdayToday.forEach(
      // biome-ignore lint: message can be overwritten here
      (person) => message = message.concat(person.toDTO().name).concat(", ")
    );
    message = message.substring(0, message.length - 2);
    new import_obsidian6.Notice(
      message.concat(
        `${personsBirthdayToday.length > 1 ? " have" : " has"} birthday`
      )
    );
  }
  async openBirthdayView() {
    const leaves = this.app.workspace.getLeavesOfType(
      BIRTHDAY_TRACKER_VIEW_TYPE
    );
    if (this.persons) {
      (await this.getBirthdayView(leaves)).displayPersons(this.persons);
    }
    this.app.workspace.revealLeaf(leaves[0]);
  }
  async getBirthdayView(leaves) {
    if (leaves.length === 0) {
      const leaf = this.app.workspace.getRightLeaf(false);
      if (leaf) {
        leaves[0] = leaf;
        await leaves[0].setViewState({ type: BIRTHDAY_TRACKER_VIEW_TYPE });
      }
    }
    return leaves[0].view;
  }
  async getPersons() {
    const content = await this.fetchContent();
    if (content) {
      this.trackBirthdaysOfContent(content);
    }
    return this.persons;
  }
  async loadSettings() {
    this.settings = { ...DEFAULT_SETTINGS, ...await this.loadData() };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */