/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// src/main.ts
__export(exports, {
  default: () => CardViewSwitcherPlugin
});

// src/components/Switcher.ts
var import_obsidian14 = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store3, ...callbacks) {
  if (store3 == null) {
    return noop;
  }
  const unsub = store3.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store3, callback) {
  component.$$.on_destroy.push(subscribe(store3, callback));
}
function set_store_value(store3, ret, value) {
  store3.set(value);
  return ret;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, false, detail);
  return e;
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance6, create_fragment6, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance6 ? instance6(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment6 ? create_fragment6($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/tslib/modules/index.js
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// src/ui/Modal.svelte
var import_obsidian12 = __toModule(require("obsidian"));

// src/Setting.ts
var import_obsidian5 = __toModule(require("obsidian"));

// src/ui/HotkeySetter.ts
var import_obsidian4 = __toModule(require("obsidian"));

// src/ui/HotkeyEntry.svelte
var import_obsidian3 = __toModule(require("obsidian"));

// src/ui/HotkeyIcon.svelte
var import_obsidian2 = __toModule(require("obsidian"));

// src/utils/Keymap.ts
var import_obsidian = __toModule(require("obsidian"));
var CODE_KEY_MAP = {
  Semicolon: ";",
  Quote: "'",
  Comma: ",",
  Period: ".",
  Slash: "/",
  BracketLeft: "[",
  BracketRight: "]",
  BackSlash: "\\",
  Backquote: "`",
  Space: " ",
  Minus: "-",
  Equal: "="
};
for (let i = 0; i < 10; i++) {
  CODE_KEY_MAP[`Digit${i}`] = i.toString();
}
for (let i = 65; i < 91; i++) {
  const char = String.fromCharCode(i);
  const upChar = char.toUpperCase();
  CODE_KEY_MAP[`Key${upChar}`] = char;
}
function convertCodeToKey(code) {
  var _a;
  return (_a = CODE_KEY_MAP[code]) != null ? _a : code;
}
function convertKeyToText(key) {
  switch (key) {
    case "ArrowLeft":
      return "\u2190";
    case "ArrowRight":
      return "\u2192";
    case "ArrowUp":
      return "\u2191";
    case "ArrowDown":
      return "\u2193";
    case "Mod":
      return import_obsidian.Platform.isMacOS ? "\u2318" : "Ctrl";
    case "Ctrl":
      return import_obsidian.Platform.isMacOS ? "\u2303" : "Ctrl";
    case "Meta":
      return import_obsidian.Platform.isMacOS ? "\u2318" : "Win";
    case "Alt":
      return import_obsidian.Platform.isMacOS ? "\u2325" : "Alt";
    case "Shift":
      return import_obsidian.Platform.isMacOS ? "\u21E7" : "Shift";
    case " ":
      return "Space";
    case "Enter":
      return "\u21B5";
    default:
      return key.charAt(0).toUpperCase() + key.slice(1);
  }
}
function convertHotkeyToText(hotkey) {
  const parts = [];
  hotkey.modifiers.forEach((mod) => {
    parts.push(convertKeyToText(mod));
  });
  const modifierPart = parts.join(" ");
  const keyPart = convertKeyToText(hotkey.key);
  return ` ${modifierPart} ${keyPart} `;
}
function compileModifiers(modifiers) {
  return modifiers.map((modifier) => {
    return modifier === "Mod" ? import_obsidian.Platform.isMacOS ? "Meta" : "Ctrl" : modifier;
  }).sort().join(",");
}
function decompileModifiers(modifiersId) {
  const modifiers = [];
  const parts = modifiersId.split(",");
  parts.forEach((s) => {
    if (import_obsidian.Platform.isMacOS && s === "Meta" || !import_obsidian.Platform.isMacOS && s === "Ctrl") {
      modifiers.push("Mod");
      return;
    }
    if (s === "Alt" || s === "Shift" || s === "Meta" || s === "Ctrl") {
      modifiers.push(s);
      return;
    }
  });
  return modifiers;
}
function getModifiers(evt) {
  const modifiers = [];
  evt.ctrlKey && modifiers.push("Ctrl");
  evt.metaKey && modifiers.push("Meta");
  evt.altKey && modifiers.push("Alt");
  evt.shiftKey && modifiers.push("Shift");
  return compileModifiers(modifiers);
}
function getHotkey(evt) {
  const modifiers = decompileModifiers(getModifiers(evt));
  const key = convertCodeToKey(evt.code);
  return {
    modifiers,
    key
  };
}
function contain(hotkeys, hotkey) {
  const hotkeyId = convertHotkeyToText(hotkey);
  return hotkeys.some((key) => {
    return hotkeyId === convertHotkeyToText(key);
  });
}

// src/ui/HotkeyIcon.svelte
function add_css(target) {
  append_styles(target, "svelte-2wacg2", ".icon-container.svelte-2wacg2{display:inline-block;cursor:pointer;width:16px;height:16px;border-radius:10px;line-height:16px;text-align:center}.icon-container.svelte-2wacg2:hover{background-color:var(--background-modifier-error);color:var(--text-on-accent)}.setting-hotkey.svelte-2wacg2{font-size:12px;background-color:var(--background-secondary-alt);border-radius:4px;padding:0 10px;min-height:24px;align-self:flex-end;position:relative}");
}
function create_fragment(ctx) {
  let span1;
  let t0_value = convertHotkeyToText(ctx[0]) + "";
  let t0;
  let t1;
  let span0;
  let mounted;
  let dispose;
  return {
    c() {
      span1 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span0 = element("span");
      attr(span0, "class", "icon-container svelte-2wacg2");
      attr(span1, "class", "setting-hotkey svelte-2wacg2");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t0);
      append(span1, t1);
      append(span1, span0);
      ctx[3](span0);
      if (!mounted) {
        dispose = listen(span0, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t0_value !== (t0_value = convertHotkeyToText(ctx2[0]) + ""))
        set_data(t0, t0_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span1);
      ctx[3](null);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { hotkey } = $$props;
  let iconContainerEl;
  const dispatcher = createEventDispatcher();
  onMount(() => {
    if (iconContainerEl instanceof HTMLSpanElement) {
      (0, import_obsidian2.setIcon)(iconContainerEl, "cross", 8);
    }
  });
  function onIconClicked() {
    dispatcher("removed");
  }
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconContainerEl = $$value;
      $$invalidate(1, iconContainerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
  };
  return [hotkey, iconContainerEl, onIconClicked, span0_binding];
}
var HotkeyIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { hotkey: 0 }, add_css);
  }
};
var HotkeyIcon_default = HotkeyIcon;

// src/ui/HotkeyEntry.svelte
function add_css2(target) {
  append_styles(target, "svelte-1my40ui", ".item-container.svelte-1my40ui{display:flex;align-items:center;padding:18px 0 18px 0;border-top:1px solid var(--background-modifier-border)}.info-container.svelte-1my40ui{flex:1 1 auto;flex-grow:1;margin-right:20px}.control-container.svelte-1my40ui{flex:1 1 auto;text-align:right;display:flex;justify-content:flex-end;align-items:center}.hotkeys-container.svelte-1my40ui{display:flex;flex-direction:column;margin-right:6px}.setting-hotkey.svelte-1my40ui{font-size:12px;background-color:var(--interactive-accent);border-radius:4px;padding:0 10px;min-height:24px;align-self:flex-end;position:relative;color:var(--text-on-accent)}.icon-container.svelte-1my40ui{padding:4px 6px;border-radius:4px;color:var(--text-faint);cursor:pointer;height:26px}.icon-container.svelte-1my40ui:hover{background-color:var(--background-secondary-alt);color:var(--text-normal)}.icon-container.svelte-1my40ui .clickable-icon{color:unset;cursor:unset;margin:unset}.icon-container.svelte-1my40ui .setting-editor-extra-setting-button{line-height:0}.icon-container.svelte-1my40ui .clickable-icon svg{position:relative;bottom:2px}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let hotkeysetting;
  let current;
  function removed_handler() {
    return ctx[8](ctx[13]);
  }
  hotkeysetting = new HotkeyIcon_default({ props: { hotkey: ctx[13] } });
  hotkeysetting.$on("removed", removed_handler);
  return {
    c() {
      create_component(hotkeysetting.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkeysetting, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const hotkeysetting_changes = {};
      if (dirty & 16)
        hotkeysetting_changes.hotkey = ctx[13];
      hotkeysetting.$set(hotkeysetting_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkeysetting.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkeysetting.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkeysetting, detaching);
    }
  };
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Press hotkey...";
      attr(div, "class", "setting-hotkey svelte-1my40ui");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment2(ctx) {
  var _a;
  let div3;
  let div0;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let t3;
  let span0;
  let t4;
  let span1;
  let current;
  let mounted;
  let dispose;
  let each_value = (_a = ctx[4]) != null ? _a : [];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = ctx[3] && create_if_block(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      span0 = element("span");
      t4 = space();
      span1 = element("span");
      attr(div0, "class", "info-container svelte-1my40ui");
      attr(div1, "class", "hotkeys-container svelte-1my40ui");
      attr(span0, "class", "icon-container svelte-1my40ui");
      attr(span1, "class", "icon-container svelte-1my40ui");
      attr(div2, "class", "control-container svelte-1my40ui");
      attr(div3, "class", "item-container svelte-1my40ui");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, t0);
      append(div3, t1);
      append(div3, div2);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      append(div1, t2);
      if (if_block)
        if_block.m(div1, null);
      append(div2, t3);
      append(div2, span0);
      ctx[9](span0);
      append(div2, t4);
      append(div2, span1);
      ctx[11](span1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span0, "click", ctx[10]),
          listen(span1, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      if (dirty & 48) {
        each_value = (_a2 = ctx2[4]) != null ? _a2 : [];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, t2);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block) {
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      ctx[9](null);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
var ICON_SIZE = 22;
function instance2($$self, $$props, $$invalidate) {
  let _hotkeys;
  let _listening;
  let { actionName } = $$props;
  let { hotkeys } = $$props;
  let { listening = false } = $$props;
  let restoreButtonEl;
  let addHotkeyButtonEl;
  const dispatcher = createEventDispatcher();
  onMount(() => {
    if (restoreButtonEl) {
      const component = new import_obsidian3.ExtraButtonComponent(restoreButtonEl).setTooltip("Restore default");
      (0, import_obsidian3.setIcon)(component.extraSettingsEl, "reset", ICON_SIZE);
    }
    if (addHotkeyButtonEl) {
      const component = new import_obsidian3.ExtraButtonComponent(addHotkeyButtonEl).setTooltip("Customize this action");
      (0, import_obsidian3.setIcon)(component.extraSettingsEl, "any-key", ICON_SIZE);
    }
  });
  const removed_handler = (hotkey) => {
    dispatcher("removed", { removed: hotkey });
  };
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      restoreButtonEl = $$value;
      $$invalidate(1, restoreButtonEl);
    });
  }
  const click_handler = () => {
    dispatcher("restored");
  };
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      addHotkeyButtonEl = $$value;
      $$invalidate(2, addHotkeyButtonEl);
    });
  }
  const click_handler_1 = () => {
    dispatcher("start-listening-keys");
  };
  $$self.$$set = ($$props2) => {
    if ("actionName" in $$props2)
      $$invalidate(0, actionName = $$props2.actionName);
    if ("hotkeys" in $$props2)
      $$invalidate(6, hotkeys = $$props2.hotkeys);
    if ("listening" in $$props2)
      $$invalidate(7, listening = $$props2.listening);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $:
        $$invalidate(4, _hotkeys = [...hotkeys !== null && hotkeys !== void 0 ? hotkeys : []]);
    }
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(3, _listening = listening);
    }
  };
  return [
    actionName,
    restoreButtonEl,
    addHotkeyButtonEl,
    _listening,
    _hotkeys,
    dispatcher,
    hotkeys,
    listening,
    removed_handler,
    span0_binding,
    click_handler,
    span1_binding,
    click_handler_1
  ];
}
var HotkeyEntry = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { actionName: 0, hotkeys: 6, listening: 7 }, add_css2);
  }
};
var HotkeyEntry_default = HotkeyEntry;

// src/ui/HotkeySetter.ts
var HotkeySetter = class {
  constructor(app2, containerEl, text2, currentHotkeys, defaultHotkeys) {
    this.shouldReflect = (_) => true;
    this.onRestored = () => {
      const { component } = this;
      if (!component)
        return;
      const renewed = [...this.defaultHotkeys];
      if (this.shouldReflect(renewed)) {
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
      }
    };
    this.onRemoved = (evt) => {
      const { component } = this;
      if (!component)
        return;
      if (!(evt instanceof CustomEvent))
        return;
      const removed = evt.detail.removed;
      const renewed = [...this.currentHotkeys];
      renewed.remove(removed);
      if (this.shouldReflect(renewed)) {
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
      }
    };
    this.onStartListening = () => {
      const { component } = this;
      if (!component)
        return;
      component.$set({
        listening: true
      });
      this.scope = new import_obsidian4.Scope();
      this.app.keymap.pushScope(this.scope);
      this.scope.register(null, null, (evt) => {
        evt.preventDefault();
        if (evt.key === "Escape") {
          component.$set({
            listening: false
          });
          if (this.scope)
            this.app.keymap.popScope(this.scope);
          return;
        }
        const hotkey = getHotkey(evt);
        const collision = contain(this.currentHotkeys, hotkey);
        if (collision)
          return;
        const renewed = [...this.currentHotkeys];
        renewed.push(hotkey);
        if (!this.shouldReflect(renewed, hotkey))
          return;
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
        component.$set({
          listening: false
        });
        if (this.scope)
          this.app.keymap.popScope(this.scope);
      });
    };
    this.app = app2;
    this.containerEl = containerEl;
    this.text = text2;
    this.currentHotkeys = [...currentHotkeys];
    this.defaultHotkeys = [...defaultHotkeys];
    this.component = this.attachComponent();
  }
  unload() {
    this.onunload();
  }
  onChanged(cb) {
    this.shouldReflect = cb;
    return this;
  }
  attachComponent() {
    const component = new HotkeyEntry_default({
      target: this.containerEl,
      props: {
        actionName: this.text,
        hotkeys: this.currentHotkeys
      }
    });
    component.$on("removed", this.onRemoved);
    component.$on("restored", this.onRestored);
    component.$on("start-listening-keys", this.onStartListening);
    return component;
  }
  onunload() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
    if (this.scope) {
      this.app.keymap.popScope(this.scope);
    }
  }
};

// src/Setting.ts
var CardViewSwitcherSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app2, plugin2) {
    super(app2, plugin2);
    this.plugin = plugin2;
    this.hotkeySetters = [];
  }
  display() {
    const { containerEl } = this;
    const { settings } = this.plugin;
    if (!settings)
      return;
    containerEl.createEl("h2", { text: "Hotkeys" });
    containerEl.createEl("h3", { text: "Card View Modal" });
    CARD_VIEW_MODAL_HOTKEY_ACTION_IDS.forEach((actionId) => {
      const hotkeys = settings.cardViewModalHotkeys[actionId];
      const defaultHotkeys = DEFAULT_SETTINGS.cardViewModalHotkeys[actionId];
      const description = HOTKEY_ACTION_INFO[actionId].description;
      const hotkeySetter = new HotkeySetter(this.app, containerEl, description, hotkeys, defaultHotkeys).onChanged((renewed, added) => {
        if (added) {
          if (added.modifiers.length === 0 && added.key !== "Enter")
            return false;
          const collision = CARD_VIEW_MODAL_HOTKEY_ACTION_IDS.some((actionId2) => {
            const hotkeys2 = settings.cardViewModalHotkeys[actionId2];
            return contain(hotkeys2, added);
          });
          if (collision) {
            new import_obsidian5.Notice("Hotkeys are conflicting!");
            return false;
          }
        }
        settings.cardViewModalHotkeys[actionId] = renewed;
        this.plugin.saveSettings();
        return true;
      });
      this.hotkeySetters.push(hotkeySetter);
    });
    containerEl.createEl("h3", { text: "Preview Modal" });
    PREVIEW_MODAL_HOTKEY_ACTION_IDS.forEach((actionId) => {
      const hotkeys = settings.previewModalHotkeys[actionId];
      const defaultHotkeys = DEFAULT_SETTINGS.previewModalHotkeys[actionId];
      const description = PREVIEW_MODAL_HOTKEY_ACTION_INFO[actionId].description;
      const hotkeySetter = new HotkeySetter(this.app, containerEl, description, hotkeys, defaultHotkeys).onChanged((renewed, added) => {
        if (added) {
          const collision = PREVIEW_MODAL_HOTKEY_ACTION_IDS.some((actionId2) => {
            const hotkeys2 = settings.previewModalHotkeys[actionId2];
            return contain(hotkeys2, added);
          });
          if (collision) {
            new import_obsidian5.Notice("Hotkeys are conflicting!");
            return false;
          }
        }
        settings.previewModalHotkeys[actionId] = renewed;
        this.plugin.saveSettings();
        return true;
      });
      this.hotkeySetters.push(hotkeySetter);
    });
  }
  hide() {
    super.hide();
    this.hotkeySetters.forEach((s) => s.unload());
    this.hotkeySetters = [];
    this.containerEl.empty();
  }
};
var DEFAULT_SETTINGS = {
  cardViewModalHotkeys: {
    selectNext: [
      {
        modifiers: ["Ctrl"],
        key: "n"
      },
      {
        modifiers: [],
        key: "ArrowDown"
      }
    ],
    selectPrevious: [
      {
        modifiers: ["Ctrl"],
        key: "p"
      },
      {
        modifiers: [],
        key: "ArrowUp"
      }
    ],
    openPreviewModal: [
      {
        modifiers: ["Ctrl"],
        key: " "
      }
    ],
    open: [
      {
        modifiers: [],
        key: "Enter"
      }
    ],
    openInNewPaneHorizontally: [
      {
        modifiers: ["Ctrl"],
        key: "Enter"
      }
    ],
    openInNewPaneVertically: [
      {
        modifiers: ["Ctrl", "Shift"],
        key: "Enter"
      }
    ],
    copyLink: [
      {
        modifiers: ["Ctrl"],
        key: "i"
      }
    ]
  },
  previewModalHotkeys: {
    scrollDown: [
      {
        modifiers: [],
        key: "ArrowDown"
      },
      {
        modifiers: ["Ctrl"],
        key: "n"
      }
    ],
    scrollUp: [
      {
        modifiers: [],
        key: "ArrowUp"
      },
      {
        modifiers: ["Ctrl"],
        key: "p"
      }
    ],
    bigScrollDown: [
      {
        modifiers: [],
        key: " "
      }
    ],
    bigScrollUp: [
      {
        modifiers: ["Shift"],
        key: " "
      }
    ],
    open: [
      {
        modifiers: [],
        key: "Enter"
      }
    ],
    openInNewPaneHorizontally: [
      {
        modifiers: ["Ctrl"],
        key: "Enter"
      }
    ],
    openInNewPaneVertically: [
      {
        modifiers: ["Ctrl", "Shift"],
        key: "Enter"
      }
    ],
    closeModal: [
      {
        modifiers: ["Ctrl"],
        key: " "
      }
    ],
    focusNext: [
      {
        modifiers: [],
        key: "Tab"
      }
    ],
    focusPrevious: [
      {
        modifiers: ["Shift"],
        key: "Tab"
      }
    ],
    toggleViewMode: [
      {
        modifiers: ["Ctrl"],
        key: "e"
      }
    ],
    copyLink: [
      {
        modifiers: ["Ctrl"],
        key: "i"
      }
    ]
  }
};
var CARD_VIEW_MODAL_HOTKEY_ACTION_IDS = [
  "selectNext",
  "selectPrevious",
  "openPreviewModal",
  "open",
  "openInNewPaneHorizontally",
  "openInNewPaneVertically",
  "copyLink"
];
var HOTKEY_ACTION_INFO = {
  selectNext: {
    description: "Select the next item",
    short: "select next"
  },
  selectPrevious: {
    description: "Select the previous item",
    short: "select previous"
  },
  openPreviewModal: {
    description: "Open preview modal",
    short: "preview"
  },
  open: {
    description: "Open the selected item",
    short: "open"
  },
  openInNewPaneVertically: {
    description: "Open the selected item in a new pane vertically",
    short: "open vertically"
  },
  openInNewPaneHorizontally: {
    description: "Open the selected item in a new pane horizontally",
    short: "open horizontally"
  },
  copyLink: {
    description: "Copy the internal link of the selected item",
    short: "copy link"
  }
};
var PREVIEW_MODAL_HOTKEY_ACTION_IDS = [
  "scrollDown",
  "scrollUp",
  "bigScrollDown",
  "bigScrollUp",
  "open",
  "openInNewPaneHorizontally",
  "openInNewPaneVertically",
  "closeModal",
  "focusNext",
  "focusPrevious",
  "toggleViewMode",
  "copyLink"
];
var PREVIEW_MODAL_HOTKEY_ACTION_INFO = {
  scrollDown: {
    description: "Scroll down a bit",
    short: "scroll down"
  },
  scrollUp: {
    description: "Scroll up a bit",
    short: "scroll up"
  },
  bigScrollDown: {
    description: "Scroll down a lot",
    short: "scroll down"
  },
  bigScrollUp: {
    description: "Scroll up a lot",
    short: "scroll up"
  },
  open: {
    description: "Open the file",
    short: "open"
  },
  openInNewPaneHorizontally: {
    description: "Open the file in a new pane horizontally",
    short: "open horizontally"
  },
  openInNewPaneVertically: {
    description: "Open the file in a new pane vertically",
    short: "open vertically"
  },
  closeModal: {
    description: "Close the modal",
    short: "close"
  },
  focusNext: {
    description: "Focus on the next match",
    short: "focus next"
  },
  focusPrevious: {
    description: "Focus on the previous match",
    short: "focus previous"
  },
  toggleViewMode: {
    description: "Toggle view mode",
    short: "change view"
  },
  copyLink: {
    description: "Copy wiki link of the file",
    short: "copy link"
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/ui/store.ts
var app = writable();
var plugin = writable();
var switcher = writable();

// src/interfaces/ViewGenerator.ts
var import_obsidian6 = __toModule(require("obsidian"));

// src/utils/Util.ts
function delay(millisecond) {
  return __async(this, null, function* () {
    yield new Promise((resolve) => setTimeout(resolve, millisecond));
  });
}
function scrollIteration(editor) {
  const line = lineCount(editor);
  if (line === void 0) {
    return void 0;
  }
  return Math.max(Math.floor(line / 1e3), 1);
}
function lineCount(editor) {
  var _a, _b, _c;
  const line = (_c = (_b = (_a = editor == null ? void 0 : editor["cm"]) == null ? void 0 : _a["state"]) == null ? void 0 : _b["doc"]) == null ? void 0 : _c.length;
  return typeof line === "number" ? line : void 0;
}
function shallowClone(obj) {
  return Object.assign({}, obj);
}
function deepClone(obj) {
  if (obj === null)
    return obj;
  if (typeof obj !== "object")
    return obj;
  if (obj instanceof Array) {
    const clone2 = new Array(obj.length);
    obj.forEach((value, id) => {
      clone2[id] = deepClone(value);
    });
    return clone2;
  }
  const clone = shallowClone(obj);
  for (const key in clone) {
    const value = clone[key];
    clone[key] = deepClone(value);
  }
  return clone;
}
function deepMerge(a, b) {
  if (b === void 0) {
    return deepClone(a);
  } else if (a === void 0) {
    return deepClone(b);
  }
  if (typeof a !== typeof b) {
    throw new Error(`failed to deepMerge ${a} and ${b}`);
  }
  if (typeof b !== "object")
    return deepClone(b);
  if (b === null) {
    return deepClone(a);
  } else if (a === null) {
    return deepClone(b);
  }
  if (b instanceof Array) {
    if (a instanceof Array) {
      return deepClone(b);
    } else {
      throw new Error(`failed to deepMerge ${a} and ${b}`);
    }
  } else if (a instanceof Array) {
    throw new Error(`failed to deepMerge ${a} and ${b}`);
  }
  const clone = shallowClone(a);
  for (const key in a) {
    clone[key] = deepMerge(a[key], b[key]);
  }
  for (const key in b) {
    clone[key] = deepMerge(a[key], b[key]);
  }
  return clone;
}

// src/interfaces/ViewGenerator.ts
var ViewGenerator = class {
  constructor(app2, containerEl, file) {
    this.extensions = [];
    this.app = app2;
    this.containerEl = containerEl;
    this.leaf = new import_obsidian6.WorkspaceLeaf(this.app);
    this.file = file;
    this.containerEl.appendChild(this.leaf.containerEl);
  }
  load(mode) {
    return __async(this, null, function* () {
      yield this.onload(mode);
      return this;
    });
  }
  unload() {
    return __async(this, null, function* () {
      this.onunload();
    });
  }
  toggleViewMode() {
    return __async(this, null, function* () {
      for (const ext of this.extensions) {
        if (!(yield ext.isMine(this.leaf)))
          continue;
        yield ext.toggleViewMode(this.leaf);
        return;
      }
    });
  }
  onload(mode) {
    return __async(this, null, function* () {
      yield this.openFile();
      for (const ext of this.extensions) {
        if (!(yield ext.isMine(this.leaf)))
          continue;
        yield ext.setViewMode(this.leaf, mode != null ? mode : "preview");
        return;
      }
    });
  }
  onunload() {
    this.leaf.detach();
  }
  openFile() {
    return __async(this, null, function* () {
      const { leaf, file } = this;
      yield leaf.openFile(file);
    });
  }
  highlightMatches(matches) {
    const view = this.leaf.view;
    if (!(view instanceof import_obsidian6.MarkdownView)) {
      return;
    }
    const editor = view.editor;
    const ranges = [];
    matches.forEach((match) => {
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      ranges.push(range);
    });
    editor.addHighlights(ranges, "highlight-search-match");
  }
  scrollIntoView(match, center) {
    return __async(this, null, function* () {
      const view = this.leaf.view;
      if (!(view instanceof import_obsidian6.MarkdownView)) {
        return;
      }
      if (view.getMode() !== "source") {
        return;
      }
      const editor = view.editor;
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      const iter = scrollIteration(editor);
      if (iter === void 0) {
        return;
      }
      for (let i = 0; i < iter; i++) {
        editor.scrollIntoView(range, center);
        yield delay(1);
      }
    });
  }
  focusOn(match, center) {
    return __async(this, null, function* () {
      const view = this.leaf.view;
      if (!(view instanceof import_obsidian6.MarkdownView)) {
        return;
      }
      if (view.getMode() !== "source") {
        return;
      }
      yield this.scrollIntoView(match, center);
      const { editor } = view;
      editor.removeHighlights("focus-search-match");
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      editor.addHighlights([range], "focus-search-match");
    });
  }
  registerExtension(ext) {
    this.extensions.push(ext);
    return this;
  }
};
var fileTypeMap = {
  md: "md",
  png: "image",
  jpg: "image",
  jpeg: "image",
  gif: "image",
  bmp: "image",
  svg: "image",
  webp: "image",
  mp3: "audio",
  webm: "audio",
  wav: "audio",
  m4a: "audio",
  ogg: "audio",
  "3gp": "audio",
  flac: "audio",
  mp4: "movie",
  ogv: "movie",
  pdf: "pdf"
};

// src/interfaces/viewGeneratorExtensions/Excalidraw.ts
var import_obsidian7 = __toModule(require("obsidian"));
var excalidrawPluginId = "obsidian-excalidraw-plugin";
var excalidrawViewType = "excalidraw";
var ExcalidrawViewGeneratorExtension = class {
  constructor(app2) {
    this.app = app2;
    const excalidraw = this.app.plugins.plugins[excalidrawPluginId];
    if (!isExcalidrawPlugin(excalidraw)) {
      this.excalidraw = void 0;
    } else {
      this.excalidraw = excalidraw;
    }
  }
  isMine(leaf) {
    return leaf.view.getViewType() === excalidrawViewType;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      const { excalidraw } = this;
      if (!excalidraw)
        return;
      excalidraw.excalidrawFileModes[leaf.id] = "markdown";
      yield excalidraw.setMarkdownView(leaf);
      if (!(leaf.view instanceof import_obsidian7.MarkdownView))
        return;
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode
      }), {});
      leaf.view.editor.blur();
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      const { excalidraw } = this;
      if (!excalidraw)
        return;
      excalidraw.excalidrawFileModes[leaf.id] = "markdown";
      yield excalidraw.setMarkdownView(leaf);
      if (!(leaf.view instanceof import_obsidian7.MarkdownView))
        return;
      const mode = leaf.view.getMode();
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode: mode === "preview" ? "source" : "preview"
      }), {});
      leaf.view.editor.blur();
    });
  }
};
function isExcalidrawPlugin(plugin2) {
  if (!(plugin2 instanceof import_obsidian7.Plugin))
    return false;
  const { excalidrawFileModes, setMarkdownView } = plugin2;
  if (typeof excalidrawFileModes !== "object")
    return false;
  if (typeof setMarkdownView !== "function")
    return false;
  return true;
}

// src/interfaces/viewGeneratorExtensions/Kanban.ts
var import_obsidian8 = __toModule(require("obsidian"));
var kanbanPluginId = "obsidian-kanban";
var frontMatterKey = "kanban-plugin";
var kanbanViewType = "kanban";
var KanbanViewGeneratorExtension = class {
  constructor(app2) {
    this.app = app2;
    const kanban = this.app.plugins.plugins[kanbanPluginId];
    if (IsKanbanPlugin(kanban)) {
      this.kanban = kanban;
    }
    if (kanban === void 0) {
      this.kanban = void 0;
    }
  }
  isMine(leaf) {
    const { view } = leaf;
    if (view.getViewType() == kanbanViewType)
      return true;
    if (!(view instanceof import_obsidian8.TextFileView))
      return false;
    const fileCache = this.app.metadataCache.getFileCache(view.file);
    const fileIsKanban = !!(fileCache == null ? void 0 : fileCache.frontmatter) && !!fileCache.frontmatter[frontMatterKey];
    return fileIsKanban;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      const { kanban } = this;
      if (!kanban)
        return;
      if (mode === "source") {
        kanban.kanbanFileModes[leaf.id] = "markdown";
        yield kanban.setMarkdownView(leaf);
        yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
          mode: "source"
        }), {});
        if (leaf.view instanceof import_obsidian8.MarkdownView) {
          leaf.view.editor.blur();
        }
      } else {
        kanban.kanbanFileModes[leaf.id] = kanbanViewType;
        yield kanban.setKanbanView(leaf);
      }
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      const { kanban } = this;
      if (!kanban)
        return;
      const mode = kanban.kanbanFileModes[leaf.id];
      yield this.setViewMode(leaf, mode === "markdown" ? "preview" : "source");
    });
  }
};
function IsKanbanPlugin(plugin2) {
  if (!(plugin2 instanceof import_obsidian8.Plugin))
    return false;
  const { kanbanFileModes, setKanbanView, setMarkdownView } = plugin2;
  if (typeof kanbanFileModes !== "object")
    return false;
  if (typeof setMarkdownView !== "function")
    return false;
  if (typeof setKanbanView !== "function")
    return false;
  return true;
}

// src/interfaces/viewGeneratorExtensions/Markdown.ts
var import_obsidian9 = __toModule(require("obsidian"));
var MarkdownViewGeneratorExtension = class {
  isMine(leaf) {
    return leaf.view instanceof import_obsidian9.MarkdownView;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode
      }), {});
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      if (!(leaf.view instanceof import_obsidian9.MarkdownView))
        return;
      yield this.setViewMode(leaf, leaf.view.getMode() === "preview" ? "source" : "preview");
    });
  }
};

// src/interfaces/viewGeneratorExtensions/NonMarkdown.ts
var import_obsidian10 = __toModule(require("obsidian"));
var NON_MARKDOWN_FILE_TYPES = ["image", "audio", "pdf", "video"];
var NonMarkdownViewGeneratorExtension = class {
  isMine(leaf) {
    if (!(leaf.view instanceof import_obsidian10.FileView))
      return false;
    return NON_MARKDOWN_FILE_TYPES.includes(leaf.view.getViewType());
  }
  setViewMode(_leaf, _mode) {
    return;
  }
  toggleViewMode(_) {
    return;
  }
};

// src/ui/CardContainer.svelte
function add_css3(target) {
  append_styles(target, "svelte-yy6vr7", ".card-container.svelte-yy6vr7.svelte-yy6vr7{overflow:hidden;display:flex;flex-direction:column;height:100%;position:relative;box-shadow:0 2px 5px rgba(0, 0, 0, 0.2);border-radius:10px;cursor:pointer;background-color:var(--background-primary);box-sizing:content-box}.card-container.svelte-yy6vr7.svelte-yy6vr7:hover{border:5px solid var(--interactive-accent);margin:-5px}.card-container.is-selected.svelte-yy6vr7.svelte-yy6vr7{border:5px solid var(--interactive-accent);margin:-5px}.card-container-header.svelte-yy6vr7.svelte-yy6vr7{padding:5px 10px;background-color:var(--background-secondary);display:flex;color:var(--text-muted)}.file-name-container.svelte-yy6vr7.svelte-yy6vr7{font-size:1rem;line-height:1.2rem;overflow-wrap:break-word;min-width:0;flex:1}.file-name-container.svelte-yy6vr7 span.matched-in-path{color:var(--text-normal);font-weight:bold}.content-container-wrapper.svelte-yy6vr7.svelte-yy6vr7{padding:5px;flex:1;height:100%;min-height:0}.content-container.svelte-yy6vr7.svelte-yy6vr7{overflow:hidden;height:100%;font-size:0.8rem;line-height:1.2}.content-container.svelte-yy6vr7 div.content-not-supported-file-format.svelte-yy6vr7{font-size:1rem;color:var(--text-muted)}.content-container.svelte-yy6vr7 p{font-size:0.8rem;line-height:1.2}.content-container.svelte-yy6vr7 code{font-size:0.8rem;line-height:1.2}.content-container.svelte-yy6vr7 div{font-size:0.8rem}.content-container.svelte-yy6vr7 li{font-size:0.8rem;line-height:1.2}.content-container.svelte-yy6vr7 h1{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-yy6vr7 h2{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-yy6vr7 h3{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-yy6vr7 h4{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-yy6vr7 h5{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-yy6vr7 h6{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-yy6vr7 a{pointer-events:none}.content-container.svelte-yy6vr7 .workspace-leaf{contain:initial !important;height:100%}.content-container.svelte-yy6vr7 .workspace-leaf-resize-handle{display:none}.content-container.svelte-yy6vr7 .view-header{display:none}.content-container.svelte-yy6vr7 .view-content{flex:1;overflow:hidden}.content-container.svelte-yy6vr7 .markdown-preview-view{padding:0;overflow:hidden}.content-container.svelte-yy6vr7 .modal-content{margin:0}");
}
function create_fragment3(ctx) {
  let div5;
  let div1;
  let div0;
  let t0;
  let div4;
  let div3;
  let div2;
  let t1_value = `${ctx[1].extension.toUpperCase()} file`;
  let t1;
  let div5_data_path_value;
  let mounted;
  let dispose;
  return {
    c() {
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      t1 = text(t1_value);
      attr(div0, "class", "file-name-container svelte-yy6vr7");
      attr(div1, "class", "card-container-header svelte-yy6vr7");
      attr(div2, "class", "content-not-supported-file-format svelte-yy6vr7");
      attr(div3, "class", "content-container svelte-yy6vr7");
      attr(div4, "class", "content-container-wrapper svelte-yy6vr7");
      attr(div5, "class", "card-container svelte-yy6vr7");
      attr(div5, "data-id", ctx[0]);
      attr(div5, "data-path", div5_data_path_value = ctx[1].path);
      toggle_class(div5, "is-selected", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, div0);
      ctx[8](div0);
      append(div5, t0);
      append(div5, div4);
      append(div4, div3);
      append(div3, div2);
      append(div2, t1);
      ctx[9](div3);
      if (!mounted) {
        dispose = listen(div5, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && t1_value !== (t1_value = `${ctx2[1].extension.toUpperCase()} file`))
        set_data(t1, t1_value);
      if (dirty & 1) {
        attr(div5, "data-id", ctx2[0]);
      }
      if (dirty & 2 && div5_data_path_value !== (div5_data_path_value = ctx2[1].path)) {
        attr(div5, "data-path", div5_data_path_value);
      }
      if (dirty & 4) {
        toggle_class(div5, "is-selected", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div5);
      ctx[8](null);
      ctx[9](null);
      mounted = false;
      dispose();
    }
  };
}
function renderFilePath(filePath, matches, containerEl) {
  let cur = 0;
  matches.forEach((match) => {
    containerEl.appendText(filePath.slice(cur, match[0]));
    containerEl.createSpan({
      text: filePath.slice(match[0], match[1]),
      cls: "matched-in-path"
    });
    cur = match[1];
  });
  containerEl.appendText(filePath.slice(cur));
}
function instance3($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(11, $app = $$value));
  let { id } = $$props;
  let { file } = $$props;
  let { matches } = $$props;
  let { selected } = $$props;
  let { focusEl } = $$props;
  let contentContainerEl;
  let fileNameContainerEl;
  let renderer;
  const dispatch = createEventDispatcher();
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    if (!fileNameContainerEl) {
      return;
    }
    renderFilePath(file.path, matches, fileNameContainerEl);
    if (!contentContainerEl) {
      return;
    }
    const fileType = fileTypeMap[file.extension];
    if (fileType !== void 0) {
      contentContainerEl.empty();
      renderer = yield new ViewGenerator($app, contentContainerEl, file).registerExtension(new ExcalidrawViewGeneratorExtension($app)).registerExtension(new KanbanViewGeneratorExtension($app)).registerExtension(new MarkdownViewGeneratorExtension()).registerExtension(new NonMarkdownViewGeneratorExtension()).load("preview");
    }
    focusEl === null || focusEl === void 0 ? void 0 : focusEl.focus();
  }));
  onDestroy(() => {
    setTimeout(() => renderer === null || renderer === void 0 ? void 0 : renderer.unload(), 1e3);
  });
  function onClicked() {
    dispatch("click");
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileNameContainerEl = $$value;
      $$invalidate(4, fileNameContainerEl);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentContainerEl = $$value;
      $$invalidate(3, contentContainerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
    if ("matches" in $$props2)
      $$invalidate(6, matches = $$props2.matches);
    if ("selected" in $$props2)
      $$invalidate(2, selected = $$props2.selected);
    if ("focusEl" in $$props2)
      $$invalidate(7, focusEl = $$props2.focusEl);
  };
  return [
    id,
    file,
    selected,
    contentContainerEl,
    fileNameContainerEl,
    onClicked,
    matches,
    focusEl,
    div0_binding,
    div3_binding
  ];
}
var CardContainer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      id: 0,
      file: 1,
      matches: 6,
      selected: 2,
      focusEl: 7
    }, add_css3);
  }
};
var CardContainer_default = CardContainer;

// src/utils/Search.ts
var import_obsidian11 = __toModule(require("obsidian"));
function fuzzySearchInFilePaths(query, files) {
  const fuzzy = (0, import_obsidian11.prepareFuzzySearch)(query);
  return files.map((file) => {
    const matchInFile = fuzzy(file.basename);
    const matchInPath = fuzzy(file.path);
    return {
      file,
      name: matchInFile,
      path: matchInPath,
      content: void 0
    };
  }).filter((item) => {
    return item.path !== null;
  });
}
function sortResultItemsInFilePathSearch(items) {
  return items.sort((a, b) => {
    var _a, _b;
    if (a.name === null && b.name === null) {
      return 0;
    }
    if (a.path !== null && b.path !== null) {
      if (a.name === null || b.name === null)
        return 0;
      if (a.name.score !== b.name.score) {
        return ((_a = b.name) == null ? void 0 : _a.score) - ((_b = a.name) == null ? void 0 : _b.score);
      }
      return a.file.name <= b.file.name ? -1 : 1;
    }
    return a.name === null ? 1 : -1;
  });
}
function searchInFiles(app2, query, files) {
  return __async(this, null, function* () {
    const search = (0, import_obsidian11.prepareSimpleSearch)(query);
    const items = [];
    for (const file of files) {
      const inName = search(file.name);
      const inPath = search(file.path);
      const inContent = file.extension === "md" ? search(yield app2.vault.cachedRead(file)) : null;
      items.push({
        file,
        name: inName,
        path: inPath,
        content: inContent
      });
    }
    return items.filter((item) => {
      return item.name !== null || item.content !== null;
    });
  });
}
function pickRandomly(array, num) {
  for (let i = 0; i < num; i++) {
    const j = Math.floor(Math.random() * array.length);
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array.slice(0, num);
}

// src/ui/Modal.svelte
function add_css4(target) {
  append_styles(target, "svelte-qhdq3h", ".modal.svelte-qhdq3h{display:flex;align-items:center;flex-direction:column;position:absolute;top:0;left:0;width:100%;height:100%;z-index:var(--layer-modal);padding:30px 50px;max-width:unset;border-radius:unset;border:unset;background-color:unset}.modal-background.svelte-qhdq3h{position:absolute;top:0;left:0;width:100%;height:100%;background-color:var(--background-modifier-cover)}.prompt-container.svelte-qhdq3h{margin-bottom:20px;background-color:var(--background-primary);padding:10px;border-radius:8px;display:flex;flex-direction:column;align-items:center;width:fit-content;z-index:1}.prompt-input.svelte-qhdq3h{max-width:700px;padding:9px 20px 8px 20px;font-size:16px;border-radius:6px;height:40px;background:var(--background-modifier-form-field);border:1px solid var(--background-modifier-border);color:var(--text-normal)}.prompt-input.svelte-qhdq3h:focus,.prompt-input.svelte-qhdq3h:active{border-color:var(--interactive-accent)}.prompt-instruction-container.svelte-qhdq3h{display:unset;margin-right:0;padding:10px 10px 2px 10px;display:flex;flex-direction:row;flex-wrap:wrap;justify-content:center}.prompt-instruction-command.svelte-qhdq3h{font-size:12px;font-weight:900;margin-right:4px}.cards-container.svelte-qhdq3h{display:grid;grid-template-columns:repeat(5, minmax(0, 1fr));grid-template-rows:repeat(2, 1fr);grid-gap:20px;height:100%;width:100%;min-height:0;z-index:1}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div;
  let span0;
  let t0_value = ctx[27].command + "";
  let t0;
  let t1;
  let span1;
  let t2_value = ctx[27].purpose + "";
  let t2;
  let t3;
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      attr(span0, "class", "prompt-instruction-command svelte-qhdq3h");
      attr(div, "class", "prompt-instruction");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(div, t1);
      append(div, span1);
      append(span1, t2);
      append(div, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block2(ctx) {
  let if_block_anchor;
  let if_block = ctx[27] && create_if_block2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[27])
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment4(ctx) {
  let div4;
  let div0;
  let t0;
  let div2;
  let input;
  let t1;
  let div1;
  let t2;
  let div3;
  let mounted;
  let dispose;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      input = element("input");
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      div3 = element("div");
      attr(div0, "class", "modal-background svelte-qhdq3h");
      attr(input, "class", "prompt-input svelte-qhdq3h");
      attr(input, "placeholder", "Hit space key to toggle the normal search mode");
      attr(div1, "class", "prompt-instruction-container svelte-qhdq3h");
      attr(div2, "class", "prompt-container svelte-qhdq3h");
      attr(div3, "class", "cards-container svelte-qhdq3h");
      attr(div4, "class", "modal svelte-qhdq3h");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div4, t0);
      append(div4, div2);
      append(div2, input);
      ctx[10](input);
      append(div2, t1);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      append(div4, t2);
      append(div4, div3);
      ctx[11](div3);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[9]),
          listen(input, "input", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value = ctx2[2];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      ctx[10](null);
      destroy_each(each_blocks, detaching);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
var CARDS_PER_PAGE = 10;
function changeMode(inputEl, evt) {
  if (evt.data === " " && inputEl.value === evt.data) {
    evt.preventDefault();
    inputEl.value = "'";
    return true;
  }
  return false;
}
function instance4($$self, $$props, $$invalidate) {
  let $app;
  let $switcher;
  let $plugin;
  component_subscribe($$self, app, ($$value) => $$invalidate(16, $app = $$value));
  component_subscribe($$self, switcher, ($$value) => $$invalidate(17, $switcher = $$value));
  component_subscribe($$self, plugin, ($$value) => $$invalidate(18, $plugin = $$value));
  const instructions = CARD_VIEW_MODAL_HOTKEY_ACTION_IDS.map((actionId) => {
    var _a;
    const hotkeys = (_a = $plugin.settings) === null || _a === void 0 ? void 0 : _a.cardViewModalHotkeys[actionId];
    if (!hotkeys)
      return void 0;
    const purpose = "to " + HOTKEY_ACTION_INFO[actionId].short;
    const cmd = hotkeys.map((hotkey) => convertHotkeyToText(hotkey)).join(", ");
    return { command: cmd, purpose };
  });
  instructions.push({ command: "esc", purpose: "to dismiss" });
  let inputEl;
  let contentEl;
  let results;
  let selected = 0;
  let page = 0;
  let cards = [];
  const searchAndRenderDebouncer = (0, import_obsidian12.debounce)(searchAndRender, 100, true);
  const dispatcher = createEventDispatcher();
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    inputEl === null || inputEl === void 0 ? void 0 : inputEl.focus();
    results = yield getResults("");
    if (contentEl instanceof HTMLElement) {
      renderCards(contentEl, results, 0);
    }
    focusOn(0);
  }));
  onDestroy(() => {
    detachCards();
  });
  function navigateForward() {
    let updated = true;
    selected++;
    if (selected >= results.length) {
      selected = results.length - 1;
      updated = false;
    }
    focusOn(selected);
    if (updated) {
      const shouldTransitNextPage = selected % CARDS_PER_PAGE === 0;
      if (shouldTransitNextPage) {
        page++;
        if (contentEl instanceof HTMLElement) {
          renderCards(contentEl, results, page);
        }
        focusOn(selected);
      }
    }
  }
  function navigateBack() {
    let updated = true;
    selected--;
    if (selected < 0) {
      selected = 0;
      updated = false;
    }
    focusOn(selected);
    if (updated) {
      const shouldTransitPreviousPage = (selected + 1) % CARDS_PER_PAGE === 0;
      if (shouldTransitPreviousPage) {
        page--;
        if (contentEl instanceof HTMLElement) {
          renderCards(contentEl, results, page);
        }
        focusOn(selected);
      }
    }
  }
  function open(direction) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (selected === void 0) {
        return;
      }
      const file = (_a = results[selected]) === null || _a === void 0 ? void 0 : _a.file;
      if (file === void 0) {
        return;
      }
      set_store_value(switcher, $switcher.shouldRestoreSelection = false, $switcher);
      yield openFile(file, direction);
      dispatcher("should-destroy");
    });
  }
  function selectedResult() {
    const result = results[selected];
    return result;
  }
  function onInput(evt) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!(evt instanceof InputEvent))
        return;
      const inputEl2 = evt.target;
      if (!(inputEl2 instanceof HTMLInputElement))
        return;
      const changed = changeMode(inputEl2, evt);
      if (changed)
        return;
      searchAndRenderDebouncer(inputEl2);
    });
  }
  function searchAndRender(inputEl2) {
    return __awaiter(this, void 0, void 0, function* () {
      selected = 0;
      page = 0;
      detachCards();
      results = yield getResults(inputEl2.value);
      if (contentEl instanceof HTMLElement) {
        renderCards(contentEl, results, 0);
      }
      focusOn(0);
    });
  }
  function focusOn(id) {
    const pos = id % CARDS_PER_PAGE;
    [-1, 0, 1].forEach((i) => {
      const card = cards[pos + i];
      if (!card)
        return;
      if (i == 0) {
        card.$set({ selected: true });
      } else {
        card.$set({ selected: false });
      }
    });
  }
  function openFile(file, direction) {
    return __awaiter(this, void 0, void 0, function* () {
      const leaf = direction !== void 0 ? $app.workspace.splitActiveLeaf(direction) : $app.workspace.getMostRecentLeaf();
      yield leaf.openFile(file);
      $app.workspace.setActiveLeaf(leaf, true, true);
    });
  }
  function getResults(query) {
    return __awaiter(this, void 0, void 0, function* () {
      let results2;
      const spaceTrimmedQuery = query.trimEnd();
      if (spaceTrimmedQuery === "") {
        const files = getRecentFiles($app);
        results2 = files.map((file) => {
          return {
            file,
            name: null,
            path: null,
            content: null
          };
        });
      } else if (spaceTrimmedQuery.startsWith("'")) {
        const trimmedQuery = spaceTrimmedQuery.replace(/^'/, "");
        const files = $app.vault.getFiles();
        const results3 = sortResultItemsInFilePathSearch(fuzzySearchInFilePaths(trimmedQuery, files));
        return results3;
      } else if (spaceTrimmedQuery.startsWith(";")) {
        const trimmedQuery = spaceTrimmedQuery.replace(/^;/, "");
        const files = $app.vault.getFiles();
        const searchResults = fuzzySearchInFilePaths(trimmedQuery, files);
        const results3 = pickRandomly(searchResults, Math.min(CARDS_PER_PAGE, searchResults.length));
        return results3;
      } else {
        const files = getRecentFiles($app);
        const results3 = yield searchInFiles($app, spaceTrimmedQuery, files);
        return results3;
      }
      return results2;
    });
  }
  function renderCards(contentEl2, results2, page2) {
    var _a, _b;
    detachCards();
    for (let id = CARDS_PER_PAGE * page2; id < CARDS_PER_PAGE * (page2 + 1); id++) {
      const result = results2[id];
      if (!result)
        continue;
      const card = new CardContainer_default({
        target: contentEl2,
        props: {
          id,
          file: result.file,
          matches: (_b = (_a = result === null || result === void 0 ? void 0 : result.path) === null || _a === void 0 ? void 0 : _a.matches) !== null && _b !== void 0 ? _b : [],
          selected: false,
          focusEl: inputEl
        }
      });
      card.$on("click", () => {
        selected = id;
        open();
      });
      cards.push(card);
    }
  }
  function detachCards() {
    cards.forEach((card) => card.$destroy());
    cards = [];
  }
  function getRecentFiles(app2) {
    const files = app2.workspace.getLastOpenFiles().map((path) => app2.vault.getAbstractFileByPath(path)).filter((file) => file instanceof import_obsidian12.TFile);
    return files;
  }
  const click_handler = () => {
    dispatcher("should-destroy");
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(0, inputEl);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(1, contentEl);
    });
  }
  return [
    inputEl,
    contentEl,
    instructions,
    dispatcher,
    onInput,
    navigateForward,
    navigateBack,
    open,
    selectedResult,
    click_handler,
    input_binding,
    div3_binding
  ];
}
var Modal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      navigateForward: 5,
      navigateBack: 6,
      open: 7,
      selectedResult: 8
    }, add_css4);
  }
  get navigateForward() {
    return this.$$.ctx[5];
  }
  get navigateBack() {
    return this.$$.ctx[6];
  }
  get open() {
    return this.$$.ctx[7];
  }
  get selectedResult() {
    return this.$$.ctx[8];
  }
};
var Modal_default = Modal;

// src/utils/Link.ts
function generateInternalLinkFrom(app2, file) {
  const text2 = getDisplayText(app2.metadataCache, file);
  return app2.fileManager.generateMarkdownLink(file, "", void 0, text2);
}
function getDisplayText(metadataCache, file) {
  const cache = metadataCache.getFileCache(file);
  if (!cache)
    return void 0;
  const title = getTitle(cache.frontmatter);
  if (title !== void 0) {
    return title;
  }
  const h1 = getFirstH1(cache.headings);
  if (h1 !== void 0) {
    return h1;
  }
  return void 0;
}
function getTitle(frontmatter) {
  return frontmatter == null ? void 0 : frontmatter["title"];
}
function getFirstH1(headings) {
  if (!headings)
    return void 0;
  for (const heading of headings) {
    if (heading.level !== 1)
      continue;
    return heading.heading;
  }
  return void 0;
}

// src/components/PreviewModal.ts
var import_obsidian13 = __toModule(require("obsidian"));

// src/ui/PreviewModalContent.svelte
function add_css5(target) {
  append_styles(target, "svelte-92zax4", ".content-container.svelte-92zax4{min-width:700px}.content-container.svelte-92zax4 .highlight-search-match{color:var(--highlight-search-match);background-color:var(--highlight-search-match-bg)}.content-container.svelte-92zax4 .focus-search-match{background-color:var(--focus-search-match-bg)}.content-container.svelte-92zax4 .workspace-leaf{contain:initial !important}.content-container.svelte-92zax4 .view-content{overflow:unset}.content-container.svelte-92zax4 .markdown-preview-view{overflow:unset}.content-container.svelte-92zax4 .workspace-leaf-content{overflow:unset}.content-container.svelte-92zax4 .workspace-leaf-resize-handle{display:none}.content-container.svelte-92zax4 .view-header{display:none}.content-container.svelte-92zax4 .markdown-preview-view{padding:0}.content-container.svelte-92zax4 .markdown-source-view{pointer-events:none}.content-container.svelte-92zax4 .workspace-leaf-content[data-type='pdf']{height:990px}.content-container.svelte-92zax4 .markdown-source-view.mod-cm6 .cm-editor{flex:initial;display:initial}.content-container.svelte-92zax4 .markdown-source-view.mod-cm6{display:initial}.content-container.svelte-92zax4 .markdown-source-view.mod-cm6 .cm-scroller{padding:0}");
}
function create_fragment5(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "content-container svelte-92zax4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[6](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[6](null);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(8, $app = $$value));
  let { file } = $$props;
  let { matches } = $$props;
  let contentContainerEl;
  let renderer;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    if (!file) {
      return;
    }
    if (!contentContainerEl) {
      return;
    }
    const fileType = fileTypeMap[file.extension];
    if (fileType !== void 0) {
      contentContainerEl.empty();
      renderer = yield new ViewGenerator($app, contentContainerEl, file).registerExtension(new ExcalidrawViewGeneratorExtension($app)).registerExtension(new KanbanViewGeneratorExtension($app)).registerExtension(new MarkdownViewGeneratorExtension()).registerExtension(new NonMarkdownViewGeneratorExtension()).load("preview");
    }
    highlightMatches();
  }));
  onDestroy(() => {
    setTimeout(() => renderer === null || renderer === void 0 ? void 0 : renderer.unload(), 1e3);
  });
  function toggleViewMode() {
    return __awaiter(this, void 0, void 0, function* () {
      yield renderer === null || renderer === void 0 ? void 0 : renderer.toggleViewMode();
    });
  }
  function highlightMatches() {
    renderer === null || renderer === void 0 ? void 0 : renderer.highlightMatches(matches !== null && matches !== void 0 ? matches : []);
  }
  function focusOn(matchId, center) {
    if (!matches)
      return;
    const match = matches[matchId];
    if (match === void 0) {
      return;
    }
    renderer === null || renderer === void 0 ? void 0 : renderer.focusOn(match, center);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentContainerEl = $$value;
      $$invalidate(0, contentContainerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
    if ("matches" in $$props2)
      $$invalidate(2, matches = $$props2.matches);
  };
  return [
    contentContainerEl,
    file,
    matches,
    toggleViewMode,
    highlightMatches,
    focusOn,
    div_binding
  ];
}
var PreviewModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      file: 1,
      matches: 2,
      toggleViewMode: 3,
      highlightMatches: 4,
      focusOn: 5
    }, add_css5);
  }
  get toggleViewMode() {
    return this.$$.ctx[3];
  }
  get highlightMatches() {
    return this.$$.ctx[4];
  }
  get focusOn() {
    return this.$$.ctx[5];
  }
};
var PreviewModalContent_default = PreviewModalContent;

// src/components/PreviewModal.ts
var SCROLL_AMOUNT = 70;
var PreviewModal = class extends import_obsidian13.Modal {
  constructor(app2, plugin2, switcher2, file, matches) {
    super(app2);
    this.plugin = plugin2;
    this.switcher = switcher2;
    this.file = file;
    this.matches = matches;
    this.currentFocus = void 0;
  }
  onOpen() {
    return __async(this, null, function* () {
      var _a;
      this.renderView();
      const hotkeyMap = (_a = this.plugin.settings) == null ? void 0 : _a.previewModalHotkeys;
      if (!hotkeyMap)
        return;
      hotkeyMap.closeModal.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          this.shouldRestoreSelection = true;
          this.close();
        });
      });
      hotkeyMap.open.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          this.openAndFocus(this.currentFocus);
          this.switcher.unload();
          this.shouldRestoreSelection = false;
          this.close();
        });
      });
      hotkeyMap.openInNewPaneHorizontally.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          this.openAndFocus(this.currentFocus, "horizontal");
          this.switcher.unload();
          this.shouldRestoreSelection = false;
          this.close();
        });
      });
      hotkeyMap.openInNewPaneVertically.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          this.openAndFocus(this.currentFocus, "vertical");
          this.switcher.unload();
          this.shouldRestoreSelection = false;
          this.close();
        });
      });
      hotkeyMap.bigScrollDown.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          this.scroll("down");
        });
      });
      hotkeyMap.bigScrollUp.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          this.scroll("up");
        });
      });
      hotkeyMap.scrollDown.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          this.scroll("down", SCROLL_AMOUNT);
        });
      });
      hotkeyMap.scrollUp.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          this.scroll("up", SCROLL_AMOUNT);
        });
      });
      hotkeyMap.focusNext.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          var _a2, _b;
          evt.preventDefault();
          const numMatches = this.countMatches();
          if (numMatches === void 0 || numMatches === 0) {
            return;
          }
          this.currentFocus = ((_a2 = this.currentFocus) != null ? _a2 : 0) + 1;
          this.currentFocus = cyclicId(this.currentFocus, numMatches);
          (_b = this.previewContent) == null ? void 0 : _b.focusOn(this.currentFocus, true);
        });
      });
      hotkeyMap.focusPrevious.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          var _a2;
          evt.preventDefault();
          const numMatches = this.countMatches();
          if (numMatches === void 0 || numMatches === 0) {
            return;
          }
          if (this.currentFocus === void 0) {
            return;
          }
          this.currentFocus--;
          this.currentFocus = cyclicId(this.currentFocus, numMatches);
          (_a2 = this.previewContent) == null ? void 0 : _a2.focusOn(this.currentFocus, true);
        });
      });
      hotkeyMap.toggleViewMode.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          (() => __async(this, null, function* () {
            var _a2, _b;
            yield (_a2 = this.previewContent) == null ? void 0 : _a2.toggleViewMode();
            (_b = this.previewContent) == null ? void 0 : _b.highlightMatches();
          }))();
        });
      });
      hotkeyMap.copyLink.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          evt.preventDefault();
          const internalLink = generateInternalLinkFrom(this.app, this.file);
          navigator.clipboard.writeText(internalLink);
          new import_obsidian13.Notice("Copy wiki link!");
        });
      });
    });
  }
  onClose() {
    var _a;
    (_a = this.previewContent) == null ? void 0 : _a.$destroy();
  }
  renderView() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.hide();
    this.previewContent = new PreviewModalContent_default({
      target: contentEl,
      props: {
        file: this.file,
        matches: this.matches
      }
    });
    contentEl.show();
  }
  countMatches() {
    return this.matches.length;
  }
  scroll(direction, px) {
    const { containerEl, contentEl } = this;
    const move = (px != null ? px : containerEl.clientHeight / 2) * (direction === "up" ? -1 : 1);
    contentEl.scrollBy({
      top: move,
      behavior: "smooth"
    });
  }
  openAndFocus(matchId, direction) {
    return __async(this, null, function* () {
      const { file } = this;
      const leaf = direction === void 0 ? this.app.workspace.getMostRecentLeaf() : this.app.workspace.splitActiveLeaf(direction);
      yield leaf.openFile(file);
      this.app.workspace.setActiveLeaf(leaf, true, true);
      if (matchId === void 0) {
        return;
      }
      const match = this.matches[matchId];
      if (!match) {
        return;
      }
      const { view } = leaf;
      if (!(view instanceof import_obsidian13.MarkdownView)) {
        return;
      }
      const editor = view.editor;
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      editor.addHighlights([range], "obsidian-search-match-highlight");
      const iter = scrollIteration(editor);
      if (iter === void 0) {
        return;
      }
      for (let i = 0; i < iter; i++) {
        editor.scrollIntoView(range, true);
      }
      editor.setCursor(range.from);
    });
  }
};
function cyclicId(id, total) {
  return (id % total + total) % total;
}

// src/components/Switcher.ts
var Switcher = class extends import_obsidian14.Component {
  constructor(app2, plugin2) {
    super();
    this.app = app2;
    this.plugin = plugin2;
    this.scope = new import_obsidian14.Scope();
    this.shouldRestoreSelection = true;
  }
  onload() {
    switcher.set(this);
    this.setHotkeys();
    this.selection = this.fetchSelection();
    this.openModal();
  }
  onunload() {
    var _a;
    this.detachHotkeys();
    (_a = this.modal) == null ? void 0 : _a.$destroy();
    if (this.shouldRestoreSelection) {
      this.restoreSelection(this.selection);
    }
  }
  openModal() {
    const paths = this.app.workspace.getLastOpenFiles();
    const files = [];
    paths.forEach((path) => {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian14.TFile) {
        files.push(file);
      }
    });
    this.modal = new Modal_default({
      target: document.body
    });
    this.modal.$on("should-destroy", () => {
      this.unload();
    });
  }
  setHotkeys() {
    var _a;
    const { settings } = this.plugin;
    if (!settings)
      return;
    const hotkeyMap = settings.cardViewModalHotkeys;
    this.app.keymap.pushScope(this.scope);
    hotkeyMap.selectPrevious.forEach((hotkey) => {
      var _a2;
      (_a2 = this.scope) == null ? void 0 : _a2.register(hotkey.modifiers, hotkey.key, (evt) => {
        var _a3;
        evt.preventDefault();
        (_a3 = this.modal) == null ? void 0 : _a3.navigateBack();
      });
    });
    hotkeyMap.selectNext.forEach((hotkey) => {
      var _a2;
      (_a2 = this.scope) == null ? void 0 : _a2.register(hotkey.modifiers, hotkey.key, (evt) => {
        var _a3;
        evt.preventDefault();
        (_a3 = this.modal) == null ? void 0 : _a3.navigateForward();
      });
    });
    if (!this.app.vault.config.legacyEditor) {
      hotkeyMap.openPreviewModal.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          var _a2, _b, _c;
          evt.preventDefault();
          const result = (_a2 = this.modal) == null ? void 0 : _a2.selectedResult();
          if (result === void 0)
            return;
          new PreviewModal(this.app, this.plugin, this, result.file, (_c = (_b = result.content) == null ? void 0 : _b.matches) != null ? _c : []).open();
        });
      });
    }
    hotkeyMap.open.forEach((hotkey) => {
      var _a2;
      (_a2 = this.scope) == null ? void 0 : _a2.register(hotkey.modifiers, hotkey.key, (evt) => {
        var _a3;
        evt.preventDefault();
        (_a3 = this.modal) == null ? void 0 : _a3.open();
      });
    });
    hotkeyMap.openInNewPaneHorizontally.forEach((hotkey) => {
      var _a2;
      (_a2 = this.scope) == null ? void 0 : _a2.register(hotkey.modifiers, hotkey.key, (evt) => {
        var _a3;
        evt.preventDefault();
        (_a3 = this.modal) == null ? void 0 : _a3.open("horizontal");
      });
    });
    hotkeyMap.openInNewPaneVertically.forEach((hotkey) => {
      this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        var _a2;
        evt.preventDefault();
        (_a2 = this.modal) == null ? void 0 : _a2.open("vertical");
      });
    });
    hotkeyMap.copyLink.forEach((hotkey) => {
      this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        var _a2;
        evt.preventDefault();
        const result = (_a2 = this.modal) == null ? void 0 : _a2.selectedResult();
        if (!result)
          return;
        const internalLink = generateInternalLinkFrom(this.app, result.file);
        navigator.clipboard.writeText(internalLink);
        new import_obsidian14.Notice("copy internal link!");
      });
    });
    (_a = this.scope) == null ? void 0 : _a.register([], "Escape", (evt) => {
      evt.preventDefault();
      this.unload();
    });
  }
  detachHotkeys() {
    this.app.keymap.popScope(this.scope);
  }
  fetchSelection() {
    const s = window.getSelection();
    if (!s)
      return void 0;
    return {
      range: s.rangeCount > 0 ? s.getRangeAt(0) : null,
      focusEl: document.activeElement
    };
  }
  restoreSelection(selection) {
    if (!selection)
      return;
    const { focusEl, range } = selection;
    if (range && document.body.contains(range.startContainer) && document.body.contains(range.endContainer)) {
      const s = window.getSelection();
      s == null ? void 0 : s.removeAllRanges();
      s == null ? void 0 : s.addRange(range);
    }
    if ((focusEl instanceof HTMLElement || focusEl instanceof SVGElement) && document.body.contains(focusEl)) {
      focusEl.focus();
    }
  }
};

// src/main.ts
var import_obsidian15 = __toModule(require("obsidian"));
var CardViewSwitcherPlugin = class extends import_obsidian15.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addCommand({
        id: "card-view-switcher:open",
        name: "Open switcher",
        callback: () => {
          this.renewSwitcher();
        }
      });
      this.addSettingTab(new CardViewSwitcherSettingTab(this.app, this));
      plugin.set(this);
      app.set(this.app);
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = deepMerge(DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  renewSwitcher() {
    if (this.switcher) {
      this.removeChild(this.switcher);
    }
    this.switcher = this.addChild(new Switcher(this.app, this));
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
